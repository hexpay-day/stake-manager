{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Stake Manager build the contracts yarn run build NOTE: sometimes tests fail if your network connection is a little slow at the time and are running for the first time after a fresh install or deleting the cache run tests yarn run foundry:test yarn run test yarn run test --trace-error # with error traces Verification Verification should occur with git hash f1180beb5322796abeaa5fd2371afb3f6a880d62 to have the correct bytecode for contract 0x209b1C66cB0Ea99DC2d4Ad13C35859DD1c258988 on Ethereum mainnet. Run Traces npx hardhat trace --hash 0xdeadbeef... # tx hash Local Development to run a node locally, simply run npx hardhat node then, in another terminal, you can run the local-development script to fund your deploy mnemonic (env: DEPLOY_MNEMONIC ) ./local-development in the case of the hexpay.day developers, they may wish to provide the following series of envs and run the local development script as noted above in order to test in a browser # where stakes will be ended / managed from TEST_ADDRESS=0xE971e07BF9917e91DFbeD9165f2ea8e6FF876880 # where contracts will be deployed from # must be first address of `DEPLOY_MNEMONIC` DEPLOY_ADDRESS=0x73CaB6c9EDA8aBc28099aF9F5dBd100Aa998Ae72 Auditors The contracts that need to be reviewed are in the contracts folder and excludes the interfaces and test folders. The reference folder contains 3 contracts: HEX.sol , HEDRON and HSIM , and COMM . The contracts folder is ~2400 sloc. The reference contract HEX.sol is ~1640 SLOC. The HEDRON and HSIM contracts are ~2700 sloc combined. The COMM contract is ~1200 sloc. NOTE: the contracts in this repo do not care about any tokens except for the ones listed above and the maximus perpetuals (custodial contract for a hex stake). That being said, it would be great if you familiarized yourself with the quirks of these 3 token contracts as they do break common practices. Metrics for the repo can be generated by running yarn run metrics . # ethereum npx hardhat --network external write:existing:end-bundle:base --wait --mev # if the above command fails, then run npx hardhat --network external write:existing:end-bundle:base --wait # pulsechain npx hardhat --network external write:existing:end-bundle:base --wait","title":"Stake Manager"},{"location":"#stake-manager","text":"build the contracts yarn run build NOTE: sometimes tests fail if your network connection is a little slow at the time and are running for the first time after a fresh install or deleting the cache run tests yarn run foundry:test yarn run test yarn run test --trace-error # with error traces","title":"Stake Manager"},{"location":"#verification","text":"Verification should occur with git hash f1180beb5322796abeaa5fd2371afb3f6a880d62 to have the correct bytecode for contract 0x209b1C66cB0Ea99DC2d4Ad13C35859DD1c258988 on Ethereum mainnet.","title":"Verification"},{"location":"#run-traces","text":"npx hardhat trace --hash 0xdeadbeef... # tx hash","title":"Run Traces"},{"location":"#local-development","text":"to run a node locally, simply run npx hardhat node then, in another terminal, you can run the local-development script to fund your deploy mnemonic (env: DEPLOY_MNEMONIC ) ./local-development in the case of the hexpay.day developers, they may wish to provide the following series of envs and run the local development script as noted above in order to test in a browser # where stakes will be ended / managed from TEST_ADDRESS=0xE971e07BF9917e91DFbeD9165f2ea8e6FF876880 # where contracts will be deployed from # must be first address of `DEPLOY_MNEMONIC` DEPLOY_ADDRESS=0x73CaB6c9EDA8aBc28099aF9F5dBd100Aa998Ae72","title":"Local Development"},{"location":"#auditors","text":"The contracts that need to be reviewed are in the contracts folder and excludes the interfaces and test folders. The reference folder contains 3 contracts: HEX.sol , HEDRON and HSIM , and COMM . The contracts folder is ~2400 sloc. The reference contract HEX.sol is ~1640 SLOC. The HEDRON and HSIM contracts are ~2700 sloc combined. The COMM contract is ~1200 sloc. NOTE: the contracts in this repo do not care about any tokens except for the ones listed above and the maximus perpetuals (custodial contract for a hex stake). That being said, it would be great if you familiarized yourself with the quirks of these 3 token contracts as they do break common practices. Metrics for the repo can be generated by running yarn run metrics . # ethereum npx hardhat --network external write:existing:end-bundle:base --wait --mev # if the above command fails, then run npx hardhat --network external write:existing:end-bundle:base --wait # pulsechain npx hardhat --network external write:existing:end-bundle:base --wait","title":"Auditors"},{"location":"Features/","text":"Features This document outlines the features available in these contracts and how they might be utilized by other contracts or stakers. Contract Entry Points Isolated Stake Manager Singleton Stake Manager Existing Stake Manager IsolatedStakeManager.sol This contract, or, more specifically it's factory, generates a contract based on the owner of the stake. Some features to understand about this contract: Anyone can create an Isolated Stake Manager (ISM) for any other address. Only the owner of the contract can start stakes. Addresses can be added as authorized end stakers. Tokens are transferred from the owner of the ISM contract to the ISM, where the stake starts. Ownership of the ISM can be transferred, even if stakes are active. Ownership is a 2 step process - OZ's Ownable2Step . Start, end, and early end capabilities can be granted to any address and persist between each round of starting and ending stakes. For this reason it is best to only grant permission in 1 direction for each address. Early end stake capabilities can be removed, even for the owner by adjusting permissions. Can be ended by external, multicall contract Has permissioned multicall to do multiple actions at same time ExistingStakeManager.sol This contract holds methods for ending hsi and maximus stakes. Anyone can deposit hsi's, that do not have hedron lent against them (must be paid off). HSI is detokenized and can be withdrawn at any time. Ability to call multiple end stakes available. End stakes and mint hedron tokens in one transaction using a public multicall. Rewards can be minted for all owned hsi's at the same time. So, no more single tx for each mint. Send reward (hedron) or target (hex) tokens to any address. Send end stake calls from external multicall. Mint hedron tokens as final step before ending stake. Multiple end stakes owned by multiple addresses are possible to end at the same time. Transfers are reduced when end stake owners are grouped. Uses a whitelist to check maximus addresses: base , trio , lucky , deci , and maxi . Allows for the deployer to connect a contract in the future, to support other perpetual pools such as hexpool.party Generates an intermediary contract for collecting fees from perpetuals with ease using previously provided (though not released and therefore codified) interface. Only allows for current perpetuals to be ended - otherwise security vulnerability is opened up. Create intermediary contract for any address. Separate authorization levels for ending stakes, flushing tokens, withdrawing. Permissioned multicall available for multiple flush and withdrawal steps. End stakes available from external multicall for reach maximization. Leave tip to be collected by transaction runner in stake's hex, stake's hedron, or any other token. Tip amount for deposited tokens based on deposit with multiplier from block.basefee. SingletonStakeManager This contract is a singleton that holds all stakes in a single contract for gas efficiency and chaining purposes. Settings for defining what to do with stakes when they are ended Auto send funds to owner or attribute in internal accounting Leave tip to be collected by transaction runner in stake's hex, stake's hedron, or any other token Tip amount for deposited tokens based on deposit with multiplier from block.basefee Restart stake using multiple functions up to 127 times or infinitely Divide funds or pull percentage of interest off the top Consent signalling by signature (eip712) Automatic stake restarting - tokens never leave contract External multicall compatible Permissioned multicall available Preference for silent failures to reduce failure cases (gas loss) Removal of stake index requirement (internally tracked) Settings to require final hedron mint during stake end Anyone can mint hedron rewards to be custodied by SingletonStakeManager Holds hedron rewards until owner collects them Low cost hedron mint authorization to allow for future skipping / upgrades to exclude from process Stake ownership can be transferred to different owners Stake tips can be replicated to new stakes when they are paid out Call GoodAccounting method for multiple stakes. Even mix the calls in with other end stakes to save gas money. Settings The settings struct holds all relevant settings for determining what tokens should go where when a stake is done as well as what the end stake call should do at the end of a stake. The properties of the settings object are as follows: name type description targetTip uint72 holds an encoded linear value to determine the amount to tip in $HEX from the stake hedronTip uint72 holds an encoded linear value to determine the amount to tip in $HEDRON from the stake newStake uint72 holds an encoded linear value to determine the amount to start a new stake with newStakeDaysMethod uint8 method to compute the number of days the new stake should last newStakeDaysMagnitude uint16 input to compute number of days new stake should last copyIterations uint8 a limiter on how many times the stake should be restarted** consentAbilities uint8 set of binary permissions to signal which actions can be taken on the stake * value below minimum signals no new stake should be created ** 0 = do not restart, 1-126 = countdown mechanism, 127 = always restart #computeMagnitude Compute magnitude is probably the most confusing method in the repo. Once broken down, it is fairly simple, but has a fair number of options which can make it confusing. Below is a breakdown of the options and features. There are 4 inputs: method , x , y , and stake The method arg determines which path (if statement) should be used. Each of these methods has its own implications for mutating the x and y values to result in another value. The situations where this method is used includes the following: - Compute ender tip - Compute withdrawable magnitude (how much to send to staker) - Compute new stake magnitude - Compute new stake days These situations can broadly be put into 2 categories: 1 manipulating inputs around an amount of hex to do something. Manipulating inputs around a number of days to do something. Amount manipulation The main directions that determines what is done with the hex after the stake ends is as follows: 1. tip the ender 1. start a new stake 1. send to owner / custody funds (remainder) The value of each of the following methods is able to be derived by using a magnitude method tip the ender ($hedron) tip the ender ($hex) start a new stake determine number of days to stake* * mostly useful for new stake days magnitude only Determining the number of days to start a stake uses a separate, pure function which is globally capped at 5_555 . Each of the tip manipulations use a method of 0-2 to determine the value to use. 0 - returns zero always 1 - returns the full input amount 2 - returns a value held in the encoded setting after 2, the values are determined by an (x/y)+b encoded in a 72 bit number. 3 - uses the total input value (principle + yield) 4 - uses the principle 5 - uses the yield after 5, the numbers are repeated through 255, with each iteration, scaling the x value in the linear encoding by a factor of 2 . Auxilliary Features The ability to create stakes that anyone has control over is an interesting feature that is not available in the current HEX staking model. The ability to create a stake for an address that does not yet exist or simply starting a stake for someone remotely is an exciting new feature that is now available to all hex stakers with these contracts. A simple model for how this could play out could be as follows: 1. Have the recipient create a wallet and send an address. 1. Start a stake for that address using the stakeStartFromBalanceFor method which will pull HEX from the sending wallet and mark the stake as owned by the designated recipient with settings that will roll the stake over, given some period. 1. Fund a small amount of eth to incent an end stake or provide appropriate settings to tip using hex. Under this pattern, they have the stake length as the amount of time to figure out how to end their stake (use DeFi). And if they are unable to figure it out, their stake is still safe and can either be custodied by the contract or rolled into a ladder. More complex patterns can be achived by launching contracts that utilize the [StakeStarter](/api/StakeStarter/) contract, such as creating NFT's (cheap) to delineate stake ownership without requiring a new contract be cloned (expensive), dead man switches, or social recovery mechanisms just to name a few. Another reason why this library makes building on top of HEX much more attractive is that stake indexes no longer have to be tracked. The contract assumes, that there is no need to track an index in an array on top of an id since, generally one only cares about the stake id being ended. If a contract wishes to keep a list, they are still free to do so, but that list will be auxillary to the globally stored stake list under [stakeIdInfo](/api/stakeIdInfo/) .","title":"Features"},{"location":"Features/#features","text":"This document outlines the features available in these contracts and how they might be utilized by other contracts or stakers.","title":"Features"},{"location":"Features/#contract-entry-points","text":"Isolated Stake Manager Singleton Stake Manager Existing Stake Manager","title":"Contract Entry Points"},{"location":"Features/#isolatedstakemanagersol","text":"This contract, or, more specifically it's factory, generates a contract based on the owner of the stake. Some features to understand about this contract: Anyone can create an Isolated Stake Manager (ISM) for any other address. Only the owner of the contract can start stakes. Addresses can be added as authorized end stakers. Tokens are transferred from the owner of the ISM contract to the ISM, where the stake starts. Ownership of the ISM can be transferred, even if stakes are active. Ownership is a 2 step process - OZ's Ownable2Step . Start, end, and early end capabilities can be granted to any address and persist between each round of starting and ending stakes. For this reason it is best to only grant permission in 1 direction for each address. Early end stake capabilities can be removed, even for the owner by adjusting permissions. Can be ended by external, multicall contract Has permissioned multicall to do multiple actions at same time","title":"IsolatedStakeManager.sol"},{"location":"Features/#existingstakemanagersol","text":"This contract holds methods for ending hsi and maximus stakes. Anyone can deposit hsi's, that do not have hedron lent against them (must be paid off). HSI is detokenized and can be withdrawn at any time. Ability to call multiple end stakes available. End stakes and mint hedron tokens in one transaction using a public multicall. Rewards can be minted for all owned hsi's at the same time. So, no more single tx for each mint. Send reward (hedron) or target (hex) tokens to any address. Send end stake calls from external multicall. Mint hedron tokens as final step before ending stake. Multiple end stakes owned by multiple addresses are possible to end at the same time. Transfers are reduced when end stake owners are grouped. Uses a whitelist to check maximus addresses: base , trio , lucky , deci , and maxi . Allows for the deployer to connect a contract in the future, to support other perpetual pools such as hexpool.party Generates an intermediary contract for collecting fees from perpetuals with ease using previously provided (though not released and therefore codified) interface. Only allows for current perpetuals to be ended - otherwise security vulnerability is opened up. Create intermediary contract for any address. Separate authorization levels for ending stakes, flushing tokens, withdrawing. Permissioned multicall available for multiple flush and withdrawal steps. End stakes available from external multicall for reach maximization. Leave tip to be collected by transaction runner in stake's hex, stake's hedron, or any other token. Tip amount for deposited tokens based on deposit with multiplier from block.basefee.","title":"ExistingStakeManager.sol"},{"location":"Features/#singletonstakemanager","text":"This contract is a singleton that holds all stakes in a single contract for gas efficiency and chaining purposes. Settings for defining what to do with stakes when they are ended Auto send funds to owner or attribute in internal accounting Leave tip to be collected by transaction runner in stake's hex, stake's hedron, or any other token Tip amount for deposited tokens based on deposit with multiplier from block.basefee Restart stake using multiple functions up to 127 times or infinitely Divide funds or pull percentage of interest off the top Consent signalling by signature (eip712) Automatic stake restarting - tokens never leave contract External multicall compatible Permissioned multicall available Preference for silent failures to reduce failure cases (gas loss) Removal of stake index requirement (internally tracked) Settings to require final hedron mint during stake end Anyone can mint hedron rewards to be custodied by SingletonStakeManager Holds hedron rewards until owner collects them Low cost hedron mint authorization to allow for future skipping / upgrades to exclude from process Stake ownership can be transferred to different owners Stake tips can be replicated to new stakes when they are paid out Call GoodAccounting method for multiple stakes. Even mix the calls in with other end stakes to save gas money.","title":"SingletonStakeManager"},{"location":"Features/#settings","text":"The settings struct holds all relevant settings for determining what tokens should go where when a stake is done as well as what the end stake call should do at the end of a stake. The properties of the settings object are as follows: name type description targetTip uint72 holds an encoded linear value to determine the amount to tip in $HEX from the stake hedronTip uint72 holds an encoded linear value to determine the amount to tip in $HEDRON from the stake newStake uint72 holds an encoded linear value to determine the amount to start a new stake with newStakeDaysMethod uint8 method to compute the number of days the new stake should last newStakeDaysMagnitude uint16 input to compute number of days new stake should last copyIterations uint8 a limiter on how many times the stake should be restarted** consentAbilities uint8 set of binary permissions to signal which actions can be taken on the stake * value below minimum signals no new stake should be created ** 0 = do not restart, 1-126 = countdown mechanism, 127 = always restart","title":"Settings"},{"location":"Features/#computemagnitude","text":"Compute magnitude is probably the most confusing method in the repo. Once broken down, it is fairly simple, but has a fair number of options which can make it confusing. Below is a breakdown of the options and features. There are 4 inputs: method , x , y , and stake The method arg determines which path (if statement) should be used. Each of these methods has its own implications for mutating the x and y values to result in another value. The situations where this method is used includes the following: - Compute ender tip - Compute withdrawable magnitude (how much to send to staker) - Compute new stake magnitude - Compute new stake days These situations can broadly be put into 2 categories: 1 manipulating inputs around an amount of hex to do something. Manipulating inputs around a number of days to do something.","title":"#computeMagnitude"},{"location":"Features/#amount-manipulation","text":"The main directions that determines what is done with the hex after the stake ends is as follows: 1. tip the ender 1. start a new stake 1. send to owner / custody funds (remainder) The value of each of the following methods is able to be derived by using a magnitude method tip the ender ($hedron) tip the ender ($hex) start a new stake determine number of days to stake* * mostly useful for new stake days magnitude only Determining the number of days to start a stake uses a separate, pure function which is globally capped at 5_555 . Each of the tip manipulations use a method of 0-2 to determine the value to use. 0 - returns zero always 1 - returns the full input amount 2 - returns a value held in the encoded setting after 2, the values are determined by an (x/y)+b encoded in a 72 bit number. 3 - uses the total input value (principle + yield) 4 - uses the principle 5 - uses the yield after 5, the numbers are repeated through 255, with each iteration, scaling the x value in the linear encoding by a factor of 2 .","title":"Amount manipulation"},{"location":"Features/#auxilliary-features","text":"The ability to create stakes that anyone has control over is an interesting feature that is not available in the current HEX staking model. The ability to create a stake for an address that does not yet exist or simply starting a stake for someone remotely is an exciting new feature that is now available to all hex stakers with these contracts. A simple model for how this could play out could be as follows: 1. Have the recipient create a wallet and send an address. 1. Start a stake for that address using the stakeStartFromBalanceFor method which will pull HEX from the sending wallet and mark the stake as owned by the designated recipient with settings that will roll the stake over, given some period. 1. Fund a small amount of eth to incent an end stake or provide appropriate settings to tip using hex. Under this pattern, they have the stake length as the amount of time to figure out how to end their stake (use DeFi). And if they are unable to figure it out, their stake is still safe and can either be custodied by the contract or rolled into a ladder. More complex patterns can be achived by launching contracts that utilize the [StakeStarter](/api/StakeStarter/) contract, such as creating NFT's (cheap) to delineate stake ownership without requiring a new contract be cloned (expensive), dead man switches, or social recovery mechanisms just to name a few. Another reason why this library makes building on top of HEX much more attractive is that stake indexes no longer have to be tracked. The contract assumes, that there is no need to track an index in an array on top of an id since, generally one only cares about the stake id being ended. If a contract wishes to keep a list, they are still free to do so, but that list will be auxillary to the globally stored stake list under [stakeIdInfo](/api/stakeIdInfo/) .","title":"Auxilliary Features"},{"location":"ToughConversation/","text":"Purpose Why do these contracts exist? Hex works fine. Does it though? If you look at a trace of a hex end stake on either Ethereum or PulseChain you will find a series of sloads, each costing 2100 gas to perform, for each and every day that the stake was active. This has been a known issue in the Hex community by any dev who has reviewed the contract. It even showed up in the audit (search \"excessive gas\") and the maximum days were adjusted to accomodate for this issue. Note, the audit shows gas prices before they were adjusted upward in the berlin hardfork ( eip-2929 ). Luckily, there is a path forward. I do not care if you end up using these contracts, I just want hexicans to not waste their gas money because they were unable to coordinate to get out of this predicament. I do think that if everyone uses the same contract to end their stake, there are huge gains in the order of 90% gas savings that can be achieved. Example of the beginning of a loop of SLOAD opcodes in a hex end stake trace: [CALL] HEX.stakeEnd{gasLimit: 27352339, gasUsed: 97795}(stakeIndex: 0, stakeId: 753528) ... [SLOAD] 0xdda06d28b5606a2fe53c7f6a483f39015a82a9bfd0de5e96eeb6c58000ba81ee \u2192 0x000000000000000658f34ca497f40089afa87a44d8e3eb000016fa69dcb20aeb [SLOAD] 0xa06aadea4af292bd92ab3bf43d1cff881c17fbc11823e091052e6f28183b54f4 \u2192 0x000000000000000658f34ca497f40089afa87a46fa9e6e000016fa69dcb20aeb [SLOAD] 0x190b667e52f43d2702b8b140846254d4c605c538cac4ffbf71bfc15a52e918ed \u2192 0x000000000000000658f34ca497f40089afa87a491c58f1000016fa69dcb20aeb [SLOAD] 0xbf2ed40e61263ec15fa26d6cd7fd7ca6eab02cf0c5b8d472b984358ce766cd2d \u2192 0x000000000000000658f34ca497f40089afa87a4b3e1374000016fa69dcb20aeb [SLOAD] 0x2b09031e28a4e057528dd5f905fd7e693380259968dae7dd73dbff908f24309b \u2192 0x000000000000000658f34ca497f40089afa87a4d5fcdf7000016fa69dcb20aeb [SLOAD] 0x288acb679d443f9827db46dcce7a64ca218532a28082f54cc182748e8738d4da \u2192 0x000000000000000658f34ca497f40089afa87a4f81887a000016fa69dcb20aeb [SLOAD] 0xbe9456aed8839ac7f86c2676ebbfe07f14df3dbf90380b8eb2207559e49efc6b \u2192 0x000000000000000658f34ca497f40089afa87a51a342fd000016fa69dcb20aeb [SLOAD] 0xc0e3d1106762ec326034dbc738125d32396159576544d62e2cec49d21cbb76cc \u2192 0x000000000000000658f34ca497f40089afa87a53c4fd80000016fa69dcb20aeb ... (continues for each day that this stake was active) What is worse is that these cost are project to increase only. The underlying cause is a merkle root that needs to be computed, which is highly compute and io (between node and it's db) intensive. Ok, let's assume that this is a good idea. Who will consent to use it? Isn't that the beauty of blockchains? Meritocracy as a mix of knowledge, actionable pathways, and consent. The question is a good one and is still a big unknown. The best answer I have for now is that someone will have to market this pathway as a better, both UX-wise and economically, way to end stakes, in some capacity. Currently the means of achieving this is reaching out to devs and asking for input / help supporting their protocol. I think we can get a lot of people on our side on this one. All grouped stakes, for example, have both a tragedy of the commons problem as well as the very real, very costly problem of ending a stake. There are vaious ways to work around this problem: Maximus, for example has opted for public end staking, which is advantageous for a repo like this because those publicly endable stakes could be ended at the same time as any stake in these contracts. Which allows us to save when ending those those existing stakes, or any other contract based stake, until devs can figure out how to migrate to using these contracts between their contracts and hex itself, if at all. I would recommend that people use grouped stake contracts like the ones mentioned already, the solution, however, is to update contracts so that end stakes are maximally efficient and run grouping pools on top of a more efficient sub structure. Speaking of that, will all projects need to redeploy and devote resources to upgrading? Unless they have an upgradable contract, which I have not seen used, yes, projects like Hedron, Maximus, or 0xStakehouse would indeed need to redeploy contracts. However, because most of the relevant hex interface can be replicated in this repo, the implementation can be very straightforward, requiring minimal changes, if any. There may also be gains that can be made by using the access list parameter in transactions (~1/21%), however, the async nature of transaction mining makes this route a bit risky, since all of the gas is paid up front. This means that even if the transaction were to fail the full storage would have already been accessed, causing huge costs with zero gain. There is a way to include this optimization, however, it has to do more with deciding when to use it since it essentially requires that the storage slots be used, otherwise, the gas is wasted. I believe this is best utilized at the front end / interface level when one can guarantee, short of the private key being used elsewhere, that the stake will be ended with that transaction. Technical Resources: * article from hardhat dev on updates * high level mechanical walk through of eip2929 and 2930 * eip 2929 * eip 2930 Ok, but there must be limits to this solution. There are. One prominant limitation is that gas costs won't make a difference if the base gas fee is still too high to fit within a single transaction. At the current limit of 1 ether transaction fee limit, the base fee must be less than 85gwei. This is a reasonable expectation within, say, a month timeframe for now and will be more relevant to more people if the price of native currencies increases, but both of those points could change in the future. What does success look like? In contract terms, success would be the majority of stakes started after these contracts are launched are ended through these contracts. Economically, success would be, at a minimum, reducing the cost of ending a stake, or even more broadly, managing a stake / principle by a fraction, at least 50%, however, I think these savings are achievable, especially for short-medium to medium-long stakes. This, value, expressed in terms of dollars could be highly valuable by itself. However, what is better is that this value compounds over time and allows hexicans to have more dollars to spend on other (non gas) things. Here are some graphs and data relevant to the issue. * https://dune.com/queries/2633637/4373958 * https://dune.com/queries/2633639 * https://dune.com/hexpay_day/end-stake-costs Note: it appears that someone did do shared end stakes at some point (5 total transactions over the course of 3 years). It seems that they stopped for some reason. Perhaps they did not understand what they were doing or shut down for other reasons and did not realize the value of what they had. For this product / library / idea to be successful, it only needs to serve legitimate end stakes and reduce the cost of ending stakes when compared to ending those stakes alone. It would be amazing if all new stakes were to be created through this system, however, anyone who is able to use this to increase their shares and reduce their stake cost is a win in my book. A measurement of success could be to compare transactions ended through this system vs txs as they would have ended through other systems. There are multiple rational, but also detrimental behaviors that occur without a library like this. 1. simply wait until a stake has ended to start a new stake with your newly aquired tokens 1. wait multiple days to end a stake since hex has 14 days before penalty is accrued from late ends during periods of high base fee Sitting in liquid hex does provide benefits, certainly. However, some people prefer sitting in tshares to not have to think about their position and this library helps reduce the psychological cost of requiring one to add liquid hex after ending stakes. Doesn't the Good Accounting method fix this? No, in fact, it makes it worse, unless you get the cached SLOAD cost. If you look at the underlying code for the good accounting method, you'll find that in order to good account, you have to do all of the calculations that the stake end method does, but the stake end method doesn't even get to take advantage of doing the calculation there and it costs the same as ending a stake. Using a public multicall, however, using a contract like this, you can good account multiple stakes at the same time, therefore saving gas funds and saving any bleeding stakes.","title":"ToughConversation"},{"location":"ToughConversation/#purpose","text":"Why do these contracts exist? Hex works fine. Does it though? If you look at a trace of a hex end stake on either Ethereum or PulseChain you will find a series of sloads, each costing 2100 gas to perform, for each and every day that the stake was active. This has been a known issue in the Hex community by any dev who has reviewed the contract. It even showed up in the audit (search \"excessive gas\") and the maximum days were adjusted to accomodate for this issue. Note, the audit shows gas prices before they were adjusted upward in the berlin hardfork ( eip-2929 ). Luckily, there is a path forward. I do not care if you end up using these contracts, I just want hexicans to not waste their gas money because they were unable to coordinate to get out of this predicament. I do think that if everyone uses the same contract to end their stake, there are huge gains in the order of 90% gas savings that can be achieved. Example of the beginning of a loop of SLOAD opcodes in a hex end stake trace: [CALL] HEX.stakeEnd{gasLimit: 27352339, gasUsed: 97795}(stakeIndex: 0, stakeId: 753528) ... [SLOAD] 0xdda06d28b5606a2fe53c7f6a483f39015a82a9bfd0de5e96eeb6c58000ba81ee \u2192 0x000000000000000658f34ca497f40089afa87a44d8e3eb000016fa69dcb20aeb [SLOAD] 0xa06aadea4af292bd92ab3bf43d1cff881c17fbc11823e091052e6f28183b54f4 \u2192 0x000000000000000658f34ca497f40089afa87a46fa9e6e000016fa69dcb20aeb [SLOAD] 0x190b667e52f43d2702b8b140846254d4c605c538cac4ffbf71bfc15a52e918ed \u2192 0x000000000000000658f34ca497f40089afa87a491c58f1000016fa69dcb20aeb [SLOAD] 0xbf2ed40e61263ec15fa26d6cd7fd7ca6eab02cf0c5b8d472b984358ce766cd2d \u2192 0x000000000000000658f34ca497f40089afa87a4b3e1374000016fa69dcb20aeb [SLOAD] 0x2b09031e28a4e057528dd5f905fd7e693380259968dae7dd73dbff908f24309b \u2192 0x000000000000000658f34ca497f40089afa87a4d5fcdf7000016fa69dcb20aeb [SLOAD] 0x288acb679d443f9827db46dcce7a64ca218532a28082f54cc182748e8738d4da \u2192 0x000000000000000658f34ca497f40089afa87a4f81887a000016fa69dcb20aeb [SLOAD] 0xbe9456aed8839ac7f86c2676ebbfe07f14df3dbf90380b8eb2207559e49efc6b \u2192 0x000000000000000658f34ca497f40089afa87a51a342fd000016fa69dcb20aeb [SLOAD] 0xc0e3d1106762ec326034dbc738125d32396159576544d62e2cec49d21cbb76cc \u2192 0x000000000000000658f34ca497f40089afa87a53c4fd80000016fa69dcb20aeb ... (continues for each day that this stake was active) What is worse is that these cost are project to increase only. The underlying cause is a merkle root that needs to be computed, which is highly compute and io (between node and it's db) intensive. Ok, let's assume that this is a good idea. Who will consent to use it? Isn't that the beauty of blockchains? Meritocracy as a mix of knowledge, actionable pathways, and consent. The question is a good one and is still a big unknown. The best answer I have for now is that someone will have to market this pathway as a better, both UX-wise and economically, way to end stakes, in some capacity. Currently the means of achieving this is reaching out to devs and asking for input / help supporting their protocol. I think we can get a lot of people on our side on this one. All grouped stakes, for example, have both a tragedy of the commons problem as well as the very real, very costly problem of ending a stake. There are vaious ways to work around this problem: Maximus, for example has opted for public end staking, which is advantageous for a repo like this because those publicly endable stakes could be ended at the same time as any stake in these contracts. Which allows us to save when ending those those existing stakes, or any other contract based stake, until devs can figure out how to migrate to using these contracts between their contracts and hex itself, if at all. I would recommend that people use grouped stake contracts like the ones mentioned already, the solution, however, is to update contracts so that end stakes are maximally efficient and run grouping pools on top of a more efficient sub structure. Speaking of that, will all projects need to redeploy and devote resources to upgrading? Unless they have an upgradable contract, which I have not seen used, yes, projects like Hedron, Maximus, or 0xStakehouse would indeed need to redeploy contracts. However, because most of the relevant hex interface can be replicated in this repo, the implementation can be very straightforward, requiring minimal changes, if any. There may also be gains that can be made by using the access list parameter in transactions (~1/21%), however, the async nature of transaction mining makes this route a bit risky, since all of the gas is paid up front. This means that even if the transaction were to fail the full storage would have already been accessed, causing huge costs with zero gain. There is a way to include this optimization, however, it has to do more with deciding when to use it since it essentially requires that the storage slots be used, otherwise, the gas is wasted. I believe this is best utilized at the front end / interface level when one can guarantee, short of the private key being used elsewhere, that the stake will be ended with that transaction. Technical Resources: * article from hardhat dev on updates * high level mechanical walk through of eip2929 and 2930 * eip 2929 * eip 2930 Ok, but there must be limits to this solution. There are. One prominant limitation is that gas costs won't make a difference if the base gas fee is still too high to fit within a single transaction. At the current limit of 1 ether transaction fee limit, the base fee must be less than 85gwei. This is a reasonable expectation within, say, a month timeframe for now and will be more relevant to more people if the price of native currencies increases, but both of those points could change in the future. What does success look like? In contract terms, success would be the majority of stakes started after these contracts are launched are ended through these contracts. Economically, success would be, at a minimum, reducing the cost of ending a stake, or even more broadly, managing a stake / principle by a fraction, at least 50%, however, I think these savings are achievable, especially for short-medium to medium-long stakes. This, value, expressed in terms of dollars could be highly valuable by itself. However, what is better is that this value compounds over time and allows hexicans to have more dollars to spend on other (non gas) things. Here are some graphs and data relevant to the issue. * https://dune.com/queries/2633637/4373958 * https://dune.com/queries/2633639 * https://dune.com/hexpay_day/end-stake-costs Note: it appears that someone did do shared end stakes at some point (5 total transactions over the course of 3 years). It seems that they stopped for some reason. Perhaps they did not understand what they were doing or shut down for other reasons and did not realize the value of what they had. For this product / library / idea to be successful, it only needs to serve legitimate end stakes and reduce the cost of ending stakes when compared to ending those stakes alone. It would be amazing if all new stakes were to be created through this system, however, anyone who is able to use this to increase their shares and reduce their stake cost is a win in my book. A measurement of success could be to compare transactions ended through this system vs txs as they would have ended through other systems. There are multiple rational, but also detrimental behaviors that occur without a library like this. 1. simply wait until a stake has ended to start a new stake with your newly aquired tokens 1. wait multiple days to end a stake since hex has 14 days before penalty is accrued from late ends during periods of high base fee Sitting in liquid hex does provide benefits, certainly. However, some people prefer sitting in tshares to not have to think about their position and this library helps reduce the psychological cost of requiring one to add liquid hex after ending stakes. Doesn't the Good Accounting method fix this? No, in fact, it makes it worse, unless you get the cached SLOAD cost. If you look at the underlying code for the good accounting method, you'll find that in order to good account, you have to do all of the calculations that the stake end method does, but the stake end method doesn't even get to take advantage of doing the calculation there and it costs the same as ending a stake. Using a public multicall, however, using a contract like this, you can good account multiple stakes at the same time, therefore saving gas funds and saving any bleeding stakes.","title":"Purpose"},{"location":"api/AuthorizationManager/","text":"AuthorizationManager This module is used to hash inputs pertaining to access control around various aspects that a developer may care about. For instance, access on a global scope vs a scope that has a reuired input may have different permission authorization mapping(bytes32 => uint256) authorization tracks which keys are provided which authorization permissions most of the time the keys will be addresses so you will often have to encode the addresses as byte32 UpdateAuthorization event UpdateAuthorization(bytes32 key, uint256 settings) emitted after settings are updated to allow various addresses and key combinations to act on owners behalf Parameters Name Type Description key bytes32 the key, usually an address, that is authorized to perform new actions settings uint256 the settings number - used as binary MAX_AUTHORIZATION uint256 MAX_AUTHORIZATION the maximum authorization value that a setting can hold - this is enforced during _setAuthorization only so it could be set elsewhere if the contract decides to constructor constructor(uint256 maxAuthorization) internal Sets up the contract by accepting a value limit during construction. Usually this is type(uint8).max or other derived value Parameters Name Type Description maxAuthorization uint256 the maximum uint that can be set on the authorization manager as a value. _setAuthorization function _setAuthorization(bytes32 key, uint256 settings) internal set the authorization status of an address Parameters Name Type Description key bytes32 the address to set the authorization flag of settings uint256 allowed to start / end / early end stakes _setAddressAuthorization function _setAddressAuthorization(address account, uint256 settings) internal sets an authorization level for an address Parameters Name Type Description account address the address to scope an authorization value settings uint256 the settings configuration in uint256 form isAddressAuthorized function isAddressAuthorized(address account, uint256 index) external view returns (bool) check if an address is authorized to perform an action this index will be different for each implementation the index is an index of the bits as in binary (1/0) Parameters Name Type Description account address the address to verify is authorized to do an action index uint256 the index of the bit to check Return Values Name Type Description [0] bool whether or not the address authorization value has a 1/0 at the provided index _isAddressAuthorized function _isAddressAuthorized(address account, uint256 index) internal view returns (bool) check if the provided address is authorized to perform an action Parameters Name Type Description account address the address to check authorization against index uint256 the index of the setting boolean to check Return Values Name Type Description [0] bool whether or not the address authorization value has a 1/0 at the provided index _isAuthorized function _isAuthorized(bytes32 key, uint256 index) internal view returns (bool) check the index of the setting for the provided key return true if flag is true Parameters Name Type Description key bytes32 the key to check against the authorization mapping index uint256 the index of the setting flag to check Return Values Name Type Description [0] bool whether or not the authorization value has a 1 or a 0 at the provided index _getAddressSettings function _getAddressSettings(address account) internal view returns (uint256) access settings scoped under an account (address) only Parameters Name Type Description account address the account whose settings you wish to access Return Values Name Type Description [0] uint256 arbitrary authorization value","title":"AuthorizationManager"},{"location":"api/AuthorizationManager/#authorizationmanager","text":"This module is used to hash inputs pertaining to access control around various aspects that a developer may care about. For instance, access on a global scope vs a scope that has a reuired input may have different permission","title":"AuthorizationManager"},{"location":"api/AuthorizationManager/#authorization","text":"mapping(bytes32 => uint256) authorization tracks which keys are provided which authorization permissions most of the time the keys will be addresses so you will often have to encode the addresses as byte32","title":"authorization"},{"location":"api/AuthorizationManager/#updateauthorization","text":"event UpdateAuthorization(bytes32 key, uint256 settings) emitted after settings are updated to allow various addresses and key combinations to act on owners behalf","title":"UpdateAuthorization"},{"location":"api/AuthorizationManager/#parameters","text":"Name Type Description key bytes32 the key, usually an address, that is authorized to perform new actions settings uint256 the settings number - used as binary","title":"Parameters"},{"location":"api/AuthorizationManager/#max_authorization","text":"uint256 MAX_AUTHORIZATION the maximum authorization value that a setting can hold - this is enforced during _setAuthorization only so it could be set elsewhere if the contract decides to","title":"MAX_AUTHORIZATION"},{"location":"api/AuthorizationManager/#constructor","text":"constructor(uint256 maxAuthorization) internal Sets up the contract by accepting a value limit during construction. Usually this is type(uint8).max or other derived value","title":"constructor"},{"location":"api/AuthorizationManager/#parameters_1","text":"Name Type Description maxAuthorization uint256 the maximum uint that can be set on the authorization manager as a value.","title":"Parameters"},{"location":"api/AuthorizationManager/#_setauthorization","text":"function _setAuthorization(bytes32 key, uint256 settings) internal set the authorization status of an address","title":"_setAuthorization"},{"location":"api/AuthorizationManager/#parameters_2","text":"Name Type Description key bytes32 the address to set the authorization flag of settings uint256 allowed to start / end / early end stakes","title":"Parameters"},{"location":"api/AuthorizationManager/#_setaddressauthorization","text":"function _setAddressAuthorization(address account, uint256 settings) internal sets an authorization level for an address","title":"_setAddressAuthorization"},{"location":"api/AuthorizationManager/#parameters_3","text":"Name Type Description account address the address to scope an authorization value settings uint256 the settings configuration in uint256 form","title":"Parameters"},{"location":"api/AuthorizationManager/#isaddressauthorized","text":"function isAddressAuthorized(address account, uint256 index) external view returns (bool) check if an address is authorized to perform an action this index will be different for each implementation the index is an index of the bits as in binary (1/0)","title":"isAddressAuthorized"},{"location":"api/AuthorizationManager/#parameters_4","text":"Name Type Description account address the address to verify is authorized to do an action index uint256 the index of the bit to check","title":"Parameters"},{"location":"api/AuthorizationManager/#return-values","text":"Name Type Description [0] bool whether or not the address authorization value has a 1/0 at the provided index","title":"Return Values"},{"location":"api/AuthorizationManager/#_isaddressauthorized","text":"function _isAddressAuthorized(address account, uint256 index) internal view returns (bool) check if the provided address is authorized to perform an action","title":"_isAddressAuthorized"},{"location":"api/AuthorizationManager/#parameters_5","text":"Name Type Description account address the address to check authorization against index uint256 the index of the setting boolean to check","title":"Parameters"},{"location":"api/AuthorizationManager/#return-values_1","text":"Name Type Description [0] bool whether or not the address authorization value has a 1/0 at the provided index","title":"Return Values"},{"location":"api/AuthorizationManager/#_isauthorized","text":"function _isAuthorized(bytes32 key, uint256 index) internal view returns (bool) check the index of the setting for the provided key return true if flag is true","title":"_isAuthorized"},{"location":"api/AuthorizationManager/#parameters_6","text":"Name Type Description key bytes32 the key to check against the authorization mapping index uint256 the index of the setting flag to check","title":"Parameters"},{"location":"api/AuthorizationManager/#return-values_2","text":"Name Type Description [0] bool whether or not the authorization value has a 1 or a 0 at the provided index","title":"Return Values"},{"location":"api/AuthorizationManager/#_getaddresssettings","text":"function _getAddressSettings(address account) internal view returns (uint256) access settings scoped under an account (address) only","title":"_getAddressSettings"},{"location":"api/AuthorizationManager/#parameters_7","text":"Name Type Description account address the account whose settings you wish to access","title":"Parameters"},{"location":"api/AuthorizationManager/#return-values_3","text":"Name Type Description [0] uint256 arbitrary authorization value","title":"Return Values"},{"location":"api/Bank/","text":"Bank CollectUnattributedToken event CollectUnattributedToken(address token, address to, uint256 amount) notes that a previously unattributed token has been collected and attributed to an address Parameters Name Type Description token address the token that is being collected by the caller to address the address that the tokens are being attributed to amount uint256 the number of tokens being collected for the to address attributed mapping(address => uint256) attributed keeps a global mapping of attributed funds that the contract is custodying withdrawableBalanceOf mapping(address => mapping(address => uint256)) withdrawableBalanceOf keeps a mapping of the withdrawable funds that the contract is custodying the contract may also be custodying tips, but an amount held within a tip is not withdrawable so it cannot be held in this mapping _getUnattributed function _getUnattributed(address token) internal view returns (uint256 amount) gets unattributed tokens floating in the contract Parameters Name Type Description token address the address of the token that you wish to get the unattributed value of Return Values Name Type Description amount uint256 representing the amount of tokens that have been deposited into the contract, which are not attributed to any address _getBalance function _getBalance(address token, address owner) internal view returns (uint256 amount) get the balance and ownership of any token Parameters Name Type Description token address the token address that you wish to get the balance of (including native) owner address the owner address to get the balance of Return Values Name Type Description amount uint256 of a balance custodied by this contract getUnattributed function getUnattributed(address token) external view returns (uint256 amount) gets the amount of unattributed tokens Parameters Name Type Description token address the token to get the unattributed balance of Return Values Name Type Description amount uint256 of a token that can be withdrawn depositToken function depositToken(address token, uint256 amount) external payable returns (uint256) transfer a given number of tokens to the contract to be used by the contract's methods an extra layer of protection is provided by this method and can be refused by calling the dangerous version Parameters Name Type Description token address amount uint256 the number of tokens to transfer to the contract depositTokenTo function depositTokenTo(address token, address to, uint256 amount) external payable returns (uint256) deposit an amount of tokens to the contract and attribute them to the provided address Parameters Name Type Description token address to address the account to give ownership over tokens amount uint256 the amount of tokens _depositTokenTo function _depositTokenTo(address token, address to, uint256 amount) internal returns (uint256) deposit a token to a given address - usually the transaction sender's Parameters Name Type Description token address the token address being deposited to address the account to attribute tokens amount uint256 the number of tokens to attribute collectUnattributed function collectUnattributed(address token, bool transferOut, address to, uint256 amount) external payable returns (uint256) collect unattributed tokens and send to recipient of choice when 0 is passed, withdraw maximum available or in other words, all unattributed tokens Parameters Name Type Description token address transferOut bool transfers tokens to the provided address to address the address to receive or have tokens attributed to amount uint256 the requested amount - clamped to the amount unattributed Return Values Name Type Description [0] uint256 withdrawable the amount attributed to the to account _collectUnattributed function _collectUnattributed(address token, bool transferOut, address to, uint256 amount, uint256 max) internal returns (uint256 withdrawable) collect any tokens that have a delta between balanceOf for this address and attributed (total) such that the difference can be withdrawn by anyone max param must be the unattributed delta or less to preserve correct accounting Parameters Name Type Description token address the token to collect unattributed of transferOut bool should transfer out to the \"to\" address to address the address to attribute or transfer to amount uint256 the number of tokens to attribute or transfer max uint256 the maximum number of tokens that can be withdrawn collectUnattributedPercent function collectUnattributedPercent(address token, bool transferOut, address recipient, uint256 basisPoints) external payable returns (uint256 amount) collect a number of unattributed tokens as basis points collecting unattributed percentages should be used before a blanket collection in order to reduce rounding errors please be sure to run blanket collect unattributed calls to collect any remaining tokens Parameters Name Type Description token address the token that you wish to collect transferOut bool whether to transfer token out recipient address the recipient of the tokens basisPoints uint256 the number of basis points (100% = 10_000) Return Values Name Type Description amount uint256 number of tokens attribued to the recipient withdrawTokenTo function withdrawTokenTo(address token, address to, uint256 amount) external payable returns (uint256) transfer an amount of tokens currently attributed to the withdrawable balance of the sender Parameters Name Type Description token address the token to transfer - uses address(0) for native to address the to of the funds amount uint256 the amount that should be deducted from the sender's balance Return Values Name Type Description [0] uint256 the amount of tokens withdrawn _getTokenBalance function _getTokenBalance(address token) internal view returns (uint256) get the balance of a given token Parameters Name Type Description token address the balance of a given token - 0x00 is ether Return Values Name Type Description [0] uint256 the balance of the given token _addToTokenWithdrawable function _addToTokenWithdrawable(address token, address to, uint256 amount) internal adds a balance to the provided staker of the magnitude given in amount Parameters Name Type Description token address the token being accounted for to address the account to add a withdrawable balance to amount uint256 the amount to add to the staker's withdrawable balance as well as the attributed tokens _deductWithdrawable function _deductWithdrawable(address token, address account, uint256 amount) internal returns (uint256 value) deduce an amount from the provided account after a deduction, funds could be considered \"unattributed\" and if they are left in such a state they could be picked up by anyone else Parameters Name Type Description token address account address the account to deduct funds from amount uint256 the amount of funds to deduct _depositTokenFrom function _depositTokenFrom(address token, address depositor, uint256 amount) internal returns (uint256 amnt) deposits tokens from a staker and marks them for that staker depositTokenUnattributed function depositTokenUnattributed(address token, uint256 amount) external deposit a number of tokens to the contract Parameters Name Type Description token address the address of the token to deposit amount uint256 the number of tokens to deposit _withdrawTokenTo function _withdrawTokenTo(address token, address to, uint256 amount) internal transfers tokens to a recipient Parameters Name Type Description token address to address where to send the tokens amount uint256 the number of tokens to send _attributeFunds function _attributeFunds(uint256 settings, address token, address staker, uint256 amount) internal Parameters Name Type Description settings uint256 the settings to determine if a token should be withdrawn to the staker token address the token address currently being targeted staker address the staker address - this account will have access to tokens either to withdraw or by dint of having access to the key amount uint256 the number of tokens to attribute or transfer","title":"Bank"},{"location":"api/Bank/#bank","text":"","title":"Bank"},{"location":"api/Bank/#collectunattributedtoken","text":"event CollectUnattributedToken(address token, address to, uint256 amount) notes that a previously unattributed token has been collected and attributed to an address","title":"CollectUnattributedToken"},{"location":"api/Bank/#parameters","text":"Name Type Description token address the token that is being collected by the caller to address the address that the tokens are being attributed to amount uint256 the number of tokens being collected for the to address","title":"Parameters"},{"location":"api/Bank/#attributed","text":"mapping(address => uint256) attributed keeps a global mapping of attributed funds that the contract is custodying","title":"attributed"},{"location":"api/Bank/#withdrawablebalanceof","text":"mapping(address => mapping(address => uint256)) withdrawableBalanceOf keeps a mapping of the withdrawable funds that the contract is custodying the contract may also be custodying tips, but an amount held within a tip is not withdrawable so it cannot be held in this mapping","title":"withdrawableBalanceOf"},{"location":"api/Bank/#_getunattributed","text":"function _getUnattributed(address token) internal view returns (uint256 amount) gets unattributed tokens floating in the contract","title":"_getUnattributed"},{"location":"api/Bank/#parameters_1","text":"Name Type Description token address the address of the token that you wish to get the unattributed value of","title":"Parameters"},{"location":"api/Bank/#return-values","text":"Name Type Description amount uint256 representing the amount of tokens that have been deposited into the contract, which are not attributed to any address","title":"Return Values"},{"location":"api/Bank/#_getbalance","text":"function _getBalance(address token, address owner) internal view returns (uint256 amount) get the balance and ownership of any token","title":"_getBalance"},{"location":"api/Bank/#parameters_2","text":"Name Type Description token address the token address that you wish to get the balance of (including native) owner address the owner address to get the balance of","title":"Parameters"},{"location":"api/Bank/#return-values_1","text":"Name Type Description amount uint256 of a balance custodied by this contract","title":"Return Values"},{"location":"api/Bank/#getunattributed","text":"function getUnattributed(address token) external view returns (uint256 amount) gets the amount of unattributed tokens","title":"getUnattributed"},{"location":"api/Bank/#parameters_3","text":"Name Type Description token address the token to get the unattributed balance of","title":"Parameters"},{"location":"api/Bank/#return-values_2","text":"Name Type Description amount uint256 of a token that can be withdrawn","title":"Return Values"},{"location":"api/Bank/#deposittoken","text":"function depositToken(address token, uint256 amount) external payable returns (uint256) transfer a given number of tokens to the contract to be used by the contract's methods an extra layer of protection is provided by this method and can be refused by calling the dangerous version","title":"depositToken"},{"location":"api/Bank/#parameters_4","text":"Name Type Description token address amount uint256 the number of tokens to transfer to the contract","title":"Parameters"},{"location":"api/Bank/#deposittokento","text":"function depositTokenTo(address token, address to, uint256 amount) external payable returns (uint256) deposit an amount of tokens to the contract and attribute them to the provided address","title":"depositTokenTo"},{"location":"api/Bank/#parameters_5","text":"Name Type Description token address to address the account to give ownership over tokens amount uint256 the amount of tokens","title":"Parameters"},{"location":"api/Bank/#_deposittokento","text":"function _depositTokenTo(address token, address to, uint256 amount) internal returns (uint256) deposit a token to a given address - usually the transaction sender's","title":"_depositTokenTo"},{"location":"api/Bank/#parameters_6","text":"Name Type Description token address the token address being deposited to address the account to attribute tokens amount uint256 the number of tokens to attribute","title":"Parameters"},{"location":"api/Bank/#collectunattributed","text":"function collectUnattributed(address token, bool transferOut, address to, uint256 amount) external payable returns (uint256) collect unattributed tokens and send to recipient of choice when 0 is passed, withdraw maximum available or in other words, all unattributed tokens","title":"collectUnattributed"},{"location":"api/Bank/#parameters_7","text":"Name Type Description token address transferOut bool transfers tokens to the provided address to address the address to receive or have tokens attributed to amount uint256 the requested amount - clamped to the amount unattributed","title":"Parameters"},{"location":"api/Bank/#return-values_3","text":"Name Type Description [0] uint256 withdrawable the amount attributed to the to account","title":"Return Values"},{"location":"api/Bank/#_collectunattributed","text":"function _collectUnattributed(address token, bool transferOut, address to, uint256 amount, uint256 max) internal returns (uint256 withdrawable) collect any tokens that have a delta between balanceOf for this address and attributed (total) such that the difference can be withdrawn by anyone max param must be the unattributed delta or less to preserve correct accounting","title":"_collectUnattributed"},{"location":"api/Bank/#parameters_8","text":"Name Type Description token address the token to collect unattributed of transferOut bool should transfer out to the \"to\" address to address the address to attribute or transfer to amount uint256 the number of tokens to attribute or transfer max uint256 the maximum number of tokens that can be withdrawn","title":"Parameters"},{"location":"api/Bank/#collectunattributedpercent","text":"function collectUnattributedPercent(address token, bool transferOut, address recipient, uint256 basisPoints) external payable returns (uint256 amount) collect a number of unattributed tokens as basis points collecting unattributed percentages should be used before a blanket collection in order to reduce rounding errors please be sure to run blanket collect unattributed calls to collect any remaining tokens","title":"collectUnattributedPercent"},{"location":"api/Bank/#parameters_9","text":"Name Type Description token address the token that you wish to collect transferOut bool whether to transfer token out recipient address the recipient of the tokens basisPoints uint256 the number of basis points (100% = 10_000)","title":"Parameters"},{"location":"api/Bank/#return-values_4","text":"Name Type Description amount uint256 number of tokens attribued to the recipient","title":"Return Values"},{"location":"api/Bank/#withdrawtokento","text":"function withdrawTokenTo(address token, address to, uint256 amount) external payable returns (uint256) transfer an amount of tokens currently attributed to the withdrawable balance of the sender","title":"withdrawTokenTo"},{"location":"api/Bank/#parameters_10","text":"Name Type Description token address the token to transfer - uses address(0) for native to address the to of the funds amount uint256 the amount that should be deducted from the sender's balance","title":"Parameters"},{"location":"api/Bank/#return-values_5","text":"Name Type Description [0] uint256 the amount of tokens withdrawn","title":"Return Values"},{"location":"api/Bank/#_gettokenbalance","text":"function _getTokenBalance(address token) internal view returns (uint256) get the balance of a given token","title":"_getTokenBalance"},{"location":"api/Bank/#parameters_11","text":"Name Type Description token address the balance of a given token - 0x00 is ether","title":"Parameters"},{"location":"api/Bank/#return-values_6","text":"Name Type Description [0] uint256 the balance of the given token","title":"Return Values"},{"location":"api/Bank/#_addtotokenwithdrawable","text":"function _addToTokenWithdrawable(address token, address to, uint256 amount) internal adds a balance to the provided staker of the magnitude given in amount","title":"_addToTokenWithdrawable"},{"location":"api/Bank/#parameters_12","text":"Name Type Description token address the token being accounted for to address the account to add a withdrawable balance to amount uint256 the amount to add to the staker's withdrawable balance as well as the attributed tokens","title":"Parameters"},{"location":"api/Bank/#_deductwithdrawable","text":"function _deductWithdrawable(address token, address account, uint256 amount) internal returns (uint256 value) deduce an amount from the provided account after a deduction, funds could be considered \"unattributed\" and if they are left in such a state they could be picked up by anyone else","title":"_deductWithdrawable"},{"location":"api/Bank/#parameters_13","text":"Name Type Description token address account address the account to deduct funds from amount uint256 the amount of funds to deduct","title":"Parameters"},{"location":"api/Bank/#_deposittokenfrom","text":"function _depositTokenFrom(address token, address depositor, uint256 amount) internal returns (uint256 amnt) deposits tokens from a staker and marks them for that staker","title":"_depositTokenFrom"},{"location":"api/Bank/#deposittokenunattributed","text":"function depositTokenUnattributed(address token, uint256 amount) external deposit a number of tokens to the contract","title":"depositTokenUnattributed"},{"location":"api/Bank/#parameters_14","text":"Name Type Description token address the address of the token to deposit amount uint256 the number of tokens to deposit","title":"Parameters"},{"location":"api/Bank/#_withdrawtokento","text":"function _withdrawTokenTo(address token, address to, uint256 amount) internal transfers tokens to a recipient","title":"_withdrawTokenTo"},{"location":"api/Bank/#parameters_15","text":"Name Type Description token address to address where to send the tokens amount uint256 the number of tokens to send","title":"Parameters"},{"location":"api/Bank/#_attributefunds","text":"function _attributeFunds(uint256 settings, address token, address staker, uint256 amount) internal","title":"_attributeFunds"},{"location":"api/Bank/#parameters_16","text":"Name Type Description settings uint256 the settings to determine if a token should be withdrawn to the staker token address the token address currently being targeted staker address the staker address - this account will have access to tokens either to withdraw or by dint of having access to the key amount uint256 the number of tokens to attribute or transfer","title":"Parameters"},{"location":"api/CurrencyList/","text":"CurrencyList AddCurrency event AddCurrency(address token, uint256 index) a new token was added to the list of acceptable tip tokens Parameters Name Type Description token address a token address was added to the list index uint256 the index of the token address in the indexToToken list MustBeHolder error MustBeHolder() must be token holder to add tokens to list indexToToken address[] indexToToken this list allows us to access from idx->address, to potentially remove an sload from tip settings depending on overlap from other stake ends currencyToIndex mapping(address => uint256) currencyToIndex maps tokens back to indexes for easy lookups off or on chain addCurrencyToList function addCurrencyToList(address token) external payable returns (uint256) creates a registry of tokens to map addresses that stakes will tip in to numbers so that they can fit in a single byteword, reducing costs when tips in the same currency occur Parameters Name Type Description token address the token to add to the list of tippable tokens Return Values Name Type Description [0] uint256 index of the token in the list - if new, it will equal the pre-push length, if already exists, it will equal the previously created index _addCurrencyToList function _addCurrencyToList(address token) internal returns (uint256) adds a hash to a list and mapping to fit them in smaller sload counts Parameters Name Type Description token address the token to add to the internally tracked list and mapping currencyListSize function currencyListSize() external view returns (uint256) reads the length of the indexToToken list to get iteration constraints Return Values Name Type Description [0] uint256 length size of the indexToToken list","title":"CurrencyList"},{"location":"api/CurrencyList/#currencylist","text":"","title":"CurrencyList"},{"location":"api/CurrencyList/#addcurrency","text":"event AddCurrency(address token, uint256 index) a new token was added to the list of acceptable tip tokens","title":"AddCurrency"},{"location":"api/CurrencyList/#parameters","text":"Name Type Description token address a token address was added to the list index uint256 the index of the token address in the indexToToken list","title":"Parameters"},{"location":"api/CurrencyList/#mustbeholder","text":"error MustBeHolder() must be token holder to add tokens to list","title":"MustBeHolder"},{"location":"api/CurrencyList/#indextotoken","text":"address[] indexToToken this list allows us to access from idx->address, to potentially remove an sload from tip settings depending on overlap from other stake ends","title":"indexToToken"},{"location":"api/CurrencyList/#currencytoindex","text":"mapping(address => uint256) currencyToIndex maps tokens back to indexes for easy lookups off or on chain","title":"currencyToIndex"},{"location":"api/CurrencyList/#addcurrencytolist","text":"function addCurrencyToList(address token) external payable returns (uint256) creates a registry of tokens to map addresses that stakes will tip in to numbers so that they can fit in a single byteword, reducing costs when tips in the same currency occur","title":"addCurrencyToList"},{"location":"api/CurrencyList/#parameters_1","text":"Name Type Description token address the token to add to the list of tippable tokens","title":"Parameters"},{"location":"api/CurrencyList/#return-values","text":"Name Type Description [0] uint256 index of the token in the list - if new, it will equal the pre-push length, if already exists, it will equal the previously created index","title":"Return Values"},{"location":"api/CurrencyList/#_addcurrencytolist","text":"function _addCurrencyToList(address token) internal returns (uint256) adds a hash to a list and mapping to fit them in smaller sload counts","title":"_addCurrencyToList"},{"location":"api/CurrencyList/#parameters_2","text":"Name Type Description token address the token to add to the internally tracked list and mapping","title":"Parameters"},{"location":"api/CurrencyList/#currencylistsize","text":"function currencyListSize() external view returns (uint256) reads the length of the indexToToken list to get iteration constraints","title":"currencyListSize"},{"location":"api/CurrencyList/#return-values_1","text":"Name Type Description [0] uint256 length size of the indexToToken list","title":"Return Values"},{"location":"api/EarningsOracle/","text":"EarningsOracle lastZeroDay uint256 lastZeroDay MAX_CATCH_UP_DAYS uint256 MAX_CATCH_UP_DAYS this max constraint is very generous given that the sstore opcode costs ~20k gas at the time of writing MAX_UINT_128 uint256 MAX_UINT_128 SHARE_SCALE uint256 SHARE_SCALE totals struct EarningsOracle.TotalStore[] totals TotalStore struct TotalStore { uint128 payout; uint128 shares; } Total struct Total { uint256 payout; uint256 shares; } constructor constructor(uint256 _lastZeroDay, uint256 untilDay) public deploy contract and start collecting data immediately. pass 0 for untilDay arg to skip collection and start with nothing in payoutTotal array Parameters Name Type Description _lastZeroDay uint256 the final day to allow zero value (used to filter out empty values) untilDay uint256 the day to end collection totalsCount function totalsCount() external view returns (uint256) the size of the payoutTotal array - correlates to days stored Return Values Name Type Description [0] uint256 the length of the totals list payoutDelta function payoutDelta(uint256 startDay, uint256 untilDay) external view returns (uint256 payout, uint256 shares) the delta between two days. untilDay argument must be greater than startDay argument otherwise call may fail Parameters Name Type Description startDay uint256 the day to start counting from untilDay uint256 the day to end with (inclusive) Return Values Name Type Description payout uint256 the delta between start and until day payout shares uint256 the delta between start and until day shares payoutDeltaTruncated function payoutDeltaTruncated(uint256 lockedDay, uint256 stakedDays, uint256 shares) external view returns (uint256 payout) multiply the difference of the payout by a constant and divide that result by the denominator subtract half of the difference between the two days to find the possible lower bound Parameters Name Type Description lockedDay uint256 the day that the stake was locked stakedDays uint256 the number of days that the stake was locked shares uint256 a number to multiply by the difference of the payout Return Values Name Type Description payout uint256 the amount estimated from shares and payout _storeDay function _storeDay(uint256 day, struct EarningsOracle.Total _total) internal returns (struct EarningsOracle.Total total) store the payout total for a given day. day must be the next day in the sequence (start with 0) day must have data available to read from the hex contract the _total arg must be handled internally - cannot be passed from external Parameters Name Type Description day uint256 the day being targeted _total struct EarningsOracle.Total _readTotals function _readTotals(uint256 day, struct EarningsOracle.Total _total) internal view returns (uint256 payout, uint256 shares) _saveDay function _saveDay(uint256 payout, uint256 shares) internal returns (struct EarningsOracle.Total total) storeDay function storeDay(uint256 day) external payable returns (struct EarningsOracle.Total total) store a singular day, only the next day in the sequence is allowed Parameters Name Type Description day uint256 the day to store incrementDay function incrementDay() external payable returns (struct EarningsOracle.Total total, uint256 day) checks the current day and increments the stored days if not yet covered Return Values Name Type Description total struct EarningsOracle.Total the summed payout and shares values from last stored day day uint256 the last stored day _storeDays function _storeDays(uint256 startDay, uint256 untilDay) internal returns (struct EarningsOracle.Total total, uint256 day) store a range of day payout information. untilDay is exclusive unless startDay and untilDay match Parameters Name Type Description startDay uint256 the day to start storing day information untilDay uint256 the day to stop storing day information Return Values Name Type Description total struct EarningsOracle.Total the summed payout and shares values from last stored day day uint256 the last stored day storeDays function storeDays(uint256 startDay, uint256 untilDay) external payable returns (struct EarningsOracle.Total total, uint256 day) store a range of day payout information. range is not constrained by max catch up days constant nor is it constrained to the current day so if it goes beyond the current day or has not yet been stored then it is subject to failure Parameters Name Type Description startDay uint256 the day to start storing day information untilDay uint256 the day to stop storing day information. Until day is inclusive Return Values Name Type Description total struct EarningsOracle.Total the summed payout and shares values from last stored day day uint256 the last stored day catchUpDays function catchUpDays(uint256 iterations) external payable returns (struct EarningsOracle.Total total, uint256 day) catch up the contract by reading up to 1_000 days of payout information at a time Parameters Name Type Description iterations uint256 the maximum number of days to iterate over - capped at 1_000 due to sload constraints Return Values Name Type Description total struct EarningsOracle.Total the summed payout and shares values from last stored day day uint256 the last stored day _validateTotals function _validateTotals(uint256 payout, uint256 shares) internal pure virtual","title":"EarningsOracle"},{"location":"api/EarningsOracle/#earningsoracle","text":"","title":"EarningsOracle"},{"location":"api/EarningsOracle/#lastzeroday","text":"uint256 lastZeroDay","title":"lastZeroDay"},{"location":"api/EarningsOracle/#max_catch_up_days","text":"uint256 MAX_CATCH_UP_DAYS this max constraint is very generous given that the sstore opcode costs ~20k gas at the time of writing","title":"MAX_CATCH_UP_DAYS"},{"location":"api/EarningsOracle/#max_uint_128","text":"uint256 MAX_UINT_128","title":"MAX_UINT_128"},{"location":"api/EarningsOracle/#share_scale","text":"uint256 SHARE_SCALE","title":"SHARE_SCALE"},{"location":"api/EarningsOracle/#totals","text":"struct EarningsOracle.TotalStore[] totals","title":"totals"},{"location":"api/EarningsOracle/#totalstore","text":"struct TotalStore { uint128 payout; uint128 shares; }","title":"TotalStore"},{"location":"api/EarningsOracle/#total","text":"struct Total { uint256 payout; uint256 shares; }","title":"Total"},{"location":"api/EarningsOracle/#constructor","text":"constructor(uint256 _lastZeroDay, uint256 untilDay) public deploy contract and start collecting data immediately. pass 0 for untilDay arg to skip collection and start with nothing in payoutTotal array","title":"constructor"},{"location":"api/EarningsOracle/#parameters","text":"Name Type Description _lastZeroDay uint256 the final day to allow zero value (used to filter out empty values) untilDay uint256 the day to end collection","title":"Parameters"},{"location":"api/EarningsOracle/#totalscount","text":"function totalsCount() external view returns (uint256) the size of the payoutTotal array - correlates to days stored","title":"totalsCount"},{"location":"api/EarningsOracle/#return-values","text":"Name Type Description [0] uint256 the length of the totals list","title":"Return Values"},{"location":"api/EarningsOracle/#payoutdelta","text":"function payoutDelta(uint256 startDay, uint256 untilDay) external view returns (uint256 payout, uint256 shares) the delta between two days. untilDay argument must be greater than startDay argument otherwise call may fail","title":"payoutDelta"},{"location":"api/EarningsOracle/#parameters_1","text":"Name Type Description startDay uint256 the day to start counting from untilDay uint256 the day to end with (inclusive)","title":"Parameters"},{"location":"api/EarningsOracle/#return-values_1","text":"Name Type Description payout uint256 the delta between start and until day payout shares uint256 the delta between start and until day shares","title":"Return Values"},{"location":"api/EarningsOracle/#payoutdeltatruncated","text":"function payoutDeltaTruncated(uint256 lockedDay, uint256 stakedDays, uint256 shares) external view returns (uint256 payout) multiply the difference of the payout by a constant and divide that result by the denominator subtract half of the difference between the two days to find the possible lower bound","title":"payoutDeltaTruncated"},{"location":"api/EarningsOracle/#parameters_2","text":"Name Type Description lockedDay uint256 the day that the stake was locked stakedDays uint256 the number of days that the stake was locked shares uint256 a number to multiply by the difference of the payout","title":"Parameters"},{"location":"api/EarningsOracle/#return-values_2","text":"Name Type Description payout uint256 the amount estimated from shares and payout","title":"Return Values"},{"location":"api/EarningsOracle/#_storeday","text":"function _storeDay(uint256 day, struct EarningsOracle.Total _total) internal returns (struct EarningsOracle.Total total) store the payout total for a given day. day must be the next day in the sequence (start with 0) day must have data available to read from the hex contract the _total arg must be handled internally - cannot be passed from external","title":"_storeDay"},{"location":"api/EarningsOracle/#parameters_3","text":"Name Type Description day uint256 the day being targeted _total struct EarningsOracle.Total","title":"Parameters"},{"location":"api/EarningsOracle/#_readtotals","text":"function _readTotals(uint256 day, struct EarningsOracle.Total _total) internal view returns (uint256 payout, uint256 shares)","title":"_readTotals"},{"location":"api/EarningsOracle/#_saveday","text":"function _saveDay(uint256 payout, uint256 shares) internal returns (struct EarningsOracle.Total total)","title":"_saveDay"},{"location":"api/EarningsOracle/#storeday","text":"function storeDay(uint256 day) external payable returns (struct EarningsOracle.Total total) store a singular day, only the next day in the sequence is allowed","title":"storeDay"},{"location":"api/EarningsOracle/#parameters_4","text":"Name Type Description day uint256 the day to store","title":"Parameters"},{"location":"api/EarningsOracle/#incrementday","text":"function incrementDay() external payable returns (struct EarningsOracle.Total total, uint256 day) checks the current day and increments the stored days if not yet covered","title":"incrementDay"},{"location":"api/EarningsOracle/#return-values_3","text":"Name Type Description total struct EarningsOracle.Total the summed payout and shares values from last stored day day uint256 the last stored day","title":"Return Values"},{"location":"api/EarningsOracle/#_storedays","text":"function _storeDays(uint256 startDay, uint256 untilDay) internal returns (struct EarningsOracle.Total total, uint256 day) store a range of day payout information. untilDay is exclusive unless startDay and untilDay match","title":"_storeDays"},{"location":"api/EarningsOracle/#parameters_5","text":"Name Type Description startDay uint256 the day to start storing day information untilDay uint256 the day to stop storing day information","title":"Parameters"},{"location":"api/EarningsOracle/#return-values_4","text":"Name Type Description total struct EarningsOracle.Total the summed payout and shares values from last stored day day uint256 the last stored day","title":"Return Values"},{"location":"api/EarningsOracle/#storedays","text":"function storeDays(uint256 startDay, uint256 untilDay) external payable returns (struct EarningsOracle.Total total, uint256 day) store a range of day payout information. range is not constrained by max catch up days constant nor is it constrained to the current day so if it goes beyond the current day or has not yet been stored then it is subject to failure","title":"storeDays"},{"location":"api/EarningsOracle/#parameters_6","text":"Name Type Description startDay uint256 the day to start storing day information untilDay uint256 the day to stop storing day information. Until day is inclusive","title":"Parameters"},{"location":"api/EarningsOracle/#return-values_5","text":"Name Type Description total struct EarningsOracle.Total the summed payout and shares values from last stored day day uint256 the last stored day","title":"Return Values"},{"location":"api/EarningsOracle/#catchupdays","text":"function catchUpDays(uint256 iterations) external payable returns (struct EarningsOracle.Total total, uint256 day) catch up the contract by reading up to 1_000 days of payout information at a time","title":"catchUpDays"},{"location":"api/EarningsOracle/#parameters_7","text":"Name Type Description iterations uint256 the maximum number of days to iterate over - capped at 1_000 due to sload constraints","title":"Parameters"},{"location":"api/EarningsOracle/#return-values_6","text":"Name Type Description total struct EarningsOracle.Total the summed payout and shares values from last stored day day uint256 the last stored day","title":"Return Values"},{"location":"api/EarningsOracle/#_validatetotals","text":"function _validateTotals(uint256 payout, uint256 shares) internal pure virtual","title":"_validateTotals"},{"location":"api/EncodableSettings/","text":"EncodableSettings UNUSED_SPACE_RIGHT_UINT8 uint8 UNUSED_SPACE_RIGHT_UINT8 UNUSED_SPACE_RIGHT_UINT16 uint8 UNUSED_SPACE_RIGHT_UINT16 UNUSED_SPACE_RIGHT_UINT64 uint8 UNUSED_SPACE_RIGHT_UINT64 INDEX_RIGHT_HEDRON_TIP uint8 INDEX_RIGHT_HEDRON_TIP INDEX_RIGHT_TARGET_TIP uint8 INDEX_RIGHT_TARGET_TIP INDEX_LEFT_TARGET_TIP uint8 INDEX_LEFT_TARGET_TIP INDEX_RIGHT_NEW_STAKE uint8 INDEX_RIGHT_NEW_STAKE INDEX_LEFT_NEW_STAKE uint8 INDEX_LEFT_NEW_STAKE INDEX_RIGHT_NEW_STAKE_DAYS_METHOD uint8 INDEX_RIGHT_NEW_STAKE_DAYS_METHOD INDEX_RIGHT_NEW_STAKE_DAYS_MAGNITUDE uint8 INDEX_RIGHT_NEW_STAKE_DAYS_MAGNITUDE INDEX_RIGHT_COPY_ITERATIONS uint8 INDEX_RIGHT_COPY_ITERATIONS INDEX_RIGHT_HAS_EXTERNAL_TIPS uint8 INDEX_RIGHT_HAS_EXTERNAL_TIPS INDEX_RIGHT_MINT_COMMUNIS_AT_END uint8 INDEX_RIGHT_MINT_COMMUNIS_AT_END INDEX_RIGHT_COPY_EXTERNAL_TIPS uint8 INDEX_RIGHT_COPY_EXTERNAL_TIPS INDEX_RIGHT_STAKE_IS_TRANSFERABLE uint8 INDEX_RIGHT_STAKE_IS_TRANSFERABLE INDEX_LEFT_STAKE_IS_TRANSFERABLE uint8 INDEX_LEFT_STAKE_IS_TRANSFERABLE INDEX_RIGHT_SHOULD_SEND_TOKENS_TO_STAKER uint8 INDEX_RIGHT_SHOULD_SEND_TOKENS_TO_STAKER INDEX_RIGHT_CAN_MINT_HEDRON_AT_END uint8 INDEX_RIGHT_CAN_MINT_HEDRON_AT_END INDEX_RIGHT_CAN_MINT_HEDRON uint8 INDEX_RIGHT_CAN_MINT_HEDRON INDEX_RIGHT_CAN_EARLY_STAKE_END uint8 INDEX_RIGHT_CAN_EARLY_STAKE_END INDEX_RIGHT_CAN_STAKE_END uint8 INDEX_RIGHT_CAN_STAKE_END stakeIdToSettings mapping(uint256 => uint256) stakeIdToSettings UpdateSettings event UpdateSettings(uint256 stakeId, uint256 settings) an event to signal that settings to direct funds at the end of a stake have been updated Parameters Name Type Description stakeId uint256 the stake id that was updated settings uint256 the newly updated settings defaultSettings function defaultSettings() external pure returns (uint256) Return Values Name Type Description [0] uint256 the default encoded settings used by end stakers to tip and end stakes _defaultSettings function _defaultSettings() internal pure virtual returns (uint256) returns the default settings number provided by this contract level updateSettings function updateSettings(uint256 stakeId, uint256 settings) external payable virtual update a stake's settings by providing a new, encoded value Parameters Name Type Description stakeId uint256 the stake id to update settings for settings uint256 the settings value to update settings for _logPreservedSettingsUpdate function _logPreservedSettingsUpdate(uint256 stakeId, uint256 settings) internal updates a stake id's settings Parameters Name Type Description stakeId uint256 the stake id to update settings for settings uint256 the settings to update against a provided stakeId. 7th index will be ignored as it is controlled by the contract _logSettingsUpdate function _logSettingsUpdate(uint256 stakeId, uint256 settings) internal update the settings for a stake id Parameters Name Type Description stakeId uint256 the stake id to update settings for settings uint256 an object that holds settings values to inform end stakers how to handle the stake decrementCopyIterations function decrementCopyIterations(uint256 settings) external pure returns (uint256) modify the second byteword from the right to appropriately decrement the number of times that these settings should be copied Parameters Name Type Description settings uint256 the settings to start with - only the 2nd byte from the right is modified Return Values Name Type Description [0] uint256 settings updated after decrementing copy iterations _decrementCopyIterations function _decrementCopyIterations(uint256 settings) internal pure returns (uint256) decrement the 2nd byte from the right if the value is < 255 Parameters Name Type Description settings uint256 the settings to start with - only the 2nd byte from the right is modified Return Values Name Type Description [0] uint256 updated encoded settings with appropriately decremented value","title":"EncodableSettings"},{"location":"api/EncodableSettings/#encodablesettings","text":"","title":"EncodableSettings"},{"location":"api/EncodableSettings/#unused_space_right_uint8","text":"uint8 UNUSED_SPACE_RIGHT_UINT8","title":"UNUSED_SPACE_RIGHT_UINT8"},{"location":"api/EncodableSettings/#unused_space_right_uint16","text":"uint8 UNUSED_SPACE_RIGHT_UINT16","title":"UNUSED_SPACE_RIGHT_UINT16"},{"location":"api/EncodableSettings/#unused_space_right_uint64","text":"uint8 UNUSED_SPACE_RIGHT_UINT64","title":"UNUSED_SPACE_RIGHT_UINT64"},{"location":"api/EncodableSettings/#index_right_hedron_tip","text":"uint8 INDEX_RIGHT_HEDRON_TIP","title":"INDEX_RIGHT_HEDRON_TIP"},{"location":"api/EncodableSettings/#index_right_target_tip","text":"uint8 INDEX_RIGHT_TARGET_TIP","title":"INDEX_RIGHT_TARGET_TIP"},{"location":"api/EncodableSettings/#index_left_target_tip","text":"uint8 INDEX_LEFT_TARGET_TIP","title":"INDEX_LEFT_TARGET_TIP"},{"location":"api/EncodableSettings/#index_right_new_stake","text":"uint8 INDEX_RIGHT_NEW_STAKE","title":"INDEX_RIGHT_NEW_STAKE"},{"location":"api/EncodableSettings/#index_left_new_stake","text":"uint8 INDEX_LEFT_NEW_STAKE","title":"INDEX_LEFT_NEW_STAKE"},{"location":"api/EncodableSettings/#index_right_new_stake_days_method","text":"uint8 INDEX_RIGHT_NEW_STAKE_DAYS_METHOD","title":"INDEX_RIGHT_NEW_STAKE_DAYS_METHOD"},{"location":"api/EncodableSettings/#index_right_new_stake_days_magnitude","text":"uint8 INDEX_RIGHT_NEW_STAKE_DAYS_MAGNITUDE","title":"INDEX_RIGHT_NEW_STAKE_DAYS_MAGNITUDE"},{"location":"api/EncodableSettings/#index_right_copy_iterations","text":"uint8 INDEX_RIGHT_COPY_ITERATIONS","title":"INDEX_RIGHT_COPY_ITERATIONS"},{"location":"api/EncodableSettings/#index_right_has_external_tips","text":"uint8 INDEX_RIGHT_HAS_EXTERNAL_TIPS","title":"INDEX_RIGHT_HAS_EXTERNAL_TIPS"},{"location":"api/EncodableSettings/#index_right_mint_communis_at_end","text":"uint8 INDEX_RIGHT_MINT_COMMUNIS_AT_END","title":"INDEX_RIGHT_MINT_COMMUNIS_AT_END"},{"location":"api/EncodableSettings/#index_right_copy_external_tips","text":"uint8 INDEX_RIGHT_COPY_EXTERNAL_TIPS","title":"INDEX_RIGHT_COPY_EXTERNAL_TIPS"},{"location":"api/EncodableSettings/#index_right_stake_is_transferable","text":"uint8 INDEX_RIGHT_STAKE_IS_TRANSFERABLE","title":"INDEX_RIGHT_STAKE_IS_TRANSFERABLE"},{"location":"api/EncodableSettings/#index_left_stake_is_transferable","text":"uint8 INDEX_LEFT_STAKE_IS_TRANSFERABLE","title":"INDEX_LEFT_STAKE_IS_TRANSFERABLE"},{"location":"api/EncodableSettings/#index_right_should_send_tokens_to_staker","text":"uint8 INDEX_RIGHT_SHOULD_SEND_TOKENS_TO_STAKER","title":"INDEX_RIGHT_SHOULD_SEND_TOKENS_TO_STAKER"},{"location":"api/EncodableSettings/#index_right_can_mint_hedron_at_end","text":"uint8 INDEX_RIGHT_CAN_MINT_HEDRON_AT_END","title":"INDEX_RIGHT_CAN_MINT_HEDRON_AT_END"},{"location":"api/EncodableSettings/#index_right_can_mint_hedron","text":"uint8 INDEX_RIGHT_CAN_MINT_HEDRON","title":"INDEX_RIGHT_CAN_MINT_HEDRON"},{"location":"api/EncodableSettings/#index_right_can_early_stake_end","text":"uint8 INDEX_RIGHT_CAN_EARLY_STAKE_END","title":"INDEX_RIGHT_CAN_EARLY_STAKE_END"},{"location":"api/EncodableSettings/#index_right_can_stake_end","text":"uint8 INDEX_RIGHT_CAN_STAKE_END","title":"INDEX_RIGHT_CAN_STAKE_END"},{"location":"api/EncodableSettings/#stakeidtosettings","text":"mapping(uint256 => uint256) stakeIdToSettings","title":"stakeIdToSettings"},{"location":"api/EncodableSettings/#updatesettings","text":"event UpdateSettings(uint256 stakeId, uint256 settings) an event to signal that settings to direct funds at the end of a stake have been updated","title":"UpdateSettings"},{"location":"api/EncodableSettings/#parameters","text":"Name Type Description stakeId uint256 the stake id that was updated settings uint256 the newly updated settings","title":"Parameters"},{"location":"api/EncodableSettings/#defaultsettings","text":"function defaultSettings() external pure returns (uint256)","title":"defaultSettings"},{"location":"api/EncodableSettings/#return-values","text":"Name Type Description [0] uint256 the default encoded settings used by end stakers to tip and end stakes","title":"Return Values"},{"location":"api/EncodableSettings/#_defaultsettings","text":"function _defaultSettings() internal pure virtual returns (uint256) returns the default settings number provided by this contract level","title":"_defaultSettings"},{"location":"api/EncodableSettings/#updatesettings_1","text":"function updateSettings(uint256 stakeId, uint256 settings) external payable virtual update a stake's settings by providing a new, encoded value","title":"updateSettings"},{"location":"api/EncodableSettings/#parameters_1","text":"Name Type Description stakeId uint256 the stake id to update settings for settings uint256 the settings value to update settings for","title":"Parameters"},{"location":"api/EncodableSettings/#_logpreservedsettingsupdate","text":"function _logPreservedSettingsUpdate(uint256 stakeId, uint256 settings) internal updates a stake id's settings","title":"_logPreservedSettingsUpdate"},{"location":"api/EncodableSettings/#parameters_2","text":"Name Type Description stakeId uint256 the stake id to update settings for settings uint256 the settings to update against a provided stakeId. 7th index will be ignored as it is controlled by the contract","title":"Parameters"},{"location":"api/EncodableSettings/#_logsettingsupdate","text":"function _logSettingsUpdate(uint256 stakeId, uint256 settings) internal update the settings for a stake id","title":"_logSettingsUpdate"},{"location":"api/EncodableSettings/#parameters_3","text":"Name Type Description stakeId uint256 the stake id to update settings for settings uint256 an object that holds settings values to inform end stakers how to handle the stake","title":"Parameters"},{"location":"api/EncodableSettings/#decrementcopyiterations","text":"function decrementCopyIterations(uint256 settings) external pure returns (uint256) modify the second byteword from the right to appropriately decrement the number of times that these settings should be copied","title":"decrementCopyIterations"},{"location":"api/EncodableSettings/#parameters_4","text":"Name Type Description settings uint256 the settings to start with - only the 2nd byte from the right is modified","title":"Parameters"},{"location":"api/EncodableSettings/#return-values_1","text":"Name Type Description [0] uint256 settings updated after decrementing copy iterations","title":"Return Values"},{"location":"api/EncodableSettings/#_decrementcopyiterations","text":"function _decrementCopyIterations(uint256 settings) internal pure returns (uint256) decrement the 2nd byte from the right if the value is < 255","title":"_decrementCopyIterations"},{"location":"api/EncodableSettings/#parameters_5","text":"Name Type Description settings uint256 the settings to start with - only the 2nd byte from the right is modified","title":"Parameters"},{"location":"api/EncodableSettings/#return-values_2","text":"Name Type Description [0] uint256 updated encoded settings with appropriately decremented value","title":"Return Values"},{"location":"api/ExistingStakeManager/","text":"ExistingStakeManager","title":"ExistingStakeManager"},{"location":"api/ExistingStakeManager/#existingstakemanager","text":"","title":"ExistingStakeManager"},{"location":"api/GoodAccounting/","text":"GoodAccounting checkAndDoStakeGoodAccounting function checkAndDoStakeGoodAccounting(uint256 stakeId) external check that the provided stake can be ended and end it Parameters Name Type Description stakeId uint256 the stake id to end as custodied by this contract checkAndDoStakeGoodAccountingFor function checkAndDoStakeGoodAccountingFor(address staker, uint256 index, uint256 stakeId) external check that the stake can be good accounted, and execute the method if it will not fail Parameters Name Type Description staker address the custodian of the provided stake index uint256 the index of the stake stakeId uint256 the stake id of the stake isGoodAccountable function isGoodAccountable(address staker, uint256 index, uint256 stakeId) external view returns (enum GoodAccounting.GoodAccountingStatus) run the appropriate checks if the stake is good accountable. return 0 if it can be good accounted return other numbers for those failed conditions Parameters Name Type Description staker address the custodian of the provided stake index uint256 the index of the stake stakeId uint256 the stake id of the stake isStakeIdGoodAccountable function isStakeIdGoodAccountable(uint256 stakeId) external view returns (enum GoodAccounting.GoodAccountingStatus) check if a stake custodied by this contract is good accountable and return its status Parameters Name Type Description stakeId uint256 the stake id to check if is good accountable Return Values Name Type Description [0] enum GoodAccounting.GoodAccountingStatus status communicating the state of the stake relative to the days GoodAccountingStatus enum GoodAccountingStatus { READY, ENDED, EARLY, MISMATCH, MISCOUNT } _isGoodAccountable function _isGoodAccountable(address staker, uint256 index, uint256 stakeId) internal view returns (enum GoodAccounting.GoodAccountingStatus) check that a given staker's stake id, at index, is good accountable Parameters Name Type Description staker address the custodian of the stake index uint256 the index of the stake in the owner's list stakeId uint256 the stake id, to ensure that the list does not shift and the index no longer matches _checkAndDoStakeGoodAccounting function _checkAndDoStakeGoodAccounting(address staker, uint256 index, uint256 stakeId) internal checks that a stake is good accountable and runs goodAccounting if it is Parameters Name Type Description staker address the custodiann of the stake index uint256 the index of the stake id stakeId uint256 the stake id to be ended stakeGoodAccounting function stakeGoodAccounting(address stakerAddr, uint256 stakeIndex, uint40 stakeIdParam) external freeze the progression of a stake to avoid penalties and preserve payout Parameters Name Type Description stakerAddr address the originating stake address stakeIndex uint256 the index of the stake on the address stakeIdParam uint40 the stake id to verify the same stake is being targeted _stakeGoodAccounting function _stakeGoodAccounting(address stakerAddr, uint256 stakeIndex, uint256 stakeIdParam) internal freeze the progression of a stake to avoid penalties and preserve payout Parameters Name Type Description stakerAddr address the originating stake address stakeIndex uint256 the index of the stake on the address stakeIdParam uint256 the stake id to verify the same stake is being targeted","title":"GoodAccounting"},{"location":"api/GoodAccounting/#goodaccounting","text":"","title":"GoodAccounting"},{"location":"api/GoodAccounting/#checkanddostakegoodaccounting","text":"function checkAndDoStakeGoodAccounting(uint256 stakeId) external check that the provided stake can be ended and end it","title":"checkAndDoStakeGoodAccounting"},{"location":"api/GoodAccounting/#parameters","text":"Name Type Description stakeId uint256 the stake id to end as custodied by this contract","title":"Parameters"},{"location":"api/GoodAccounting/#checkanddostakegoodaccountingfor","text":"function checkAndDoStakeGoodAccountingFor(address staker, uint256 index, uint256 stakeId) external check that the stake can be good accounted, and execute the method if it will not fail","title":"checkAndDoStakeGoodAccountingFor"},{"location":"api/GoodAccounting/#parameters_1","text":"Name Type Description staker address the custodian of the provided stake index uint256 the index of the stake stakeId uint256 the stake id of the stake","title":"Parameters"},{"location":"api/GoodAccounting/#isgoodaccountable","text":"function isGoodAccountable(address staker, uint256 index, uint256 stakeId) external view returns (enum GoodAccounting.GoodAccountingStatus) run the appropriate checks if the stake is good accountable. return 0 if it can be good accounted return other numbers for those failed conditions","title":"isGoodAccountable"},{"location":"api/GoodAccounting/#parameters_2","text":"Name Type Description staker address the custodian of the provided stake index uint256 the index of the stake stakeId uint256 the stake id of the stake","title":"Parameters"},{"location":"api/GoodAccounting/#isstakeidgoodaccountable","text":"function isStakeIdGoodAccountable(uint256 stakeId) external view returns (enum GoodAccounting.GoodAccountingStatus) check if a stake custodied by this contract is good accountable and return its status","title":"isStakeIdGoodAccountable"},{"location":"api/GoodAccounting/#parameters_3","text":"Name Type Description stakeId uint256 the stake id to check if is good accountable","title":"Parameters"},{"location":"api/GoodAccounting/#return-values","text":"Name Type Description [0] enum GoodAccounting.GoodAccountingStatus status communicating the state of the stake relative to the days","title":"Return Values"},{"location":"api/GoodAccounting/#goodaccountingstatus","text":"enum GoodAccountingStatus { READY, ENDED, EARLY, MISMATCH, MISCOUNT }","title":"GoodAccountingStatus"},{"location":"api/GoodAccounting/#_isgoodaccountable","text":"function _isGoodAccountable(address staker, uint256 index, uint256 stakeId) internal view returns (enum GoodAccounting.GoodAccountingStatus) check that a given staker's stake id, at index, is good accountable","title":"_isGoodAccountable"},{"location":"api/GoodAccounting/#parameters_4","text":"Name Type Description staker address the custodian of the stake index uint256 the index of the stake in the owner's list stakeId uint256 the stake id, to ensure that the list does not shift and the index no longer matches","title":"Parameters"},{"location":"api/GoodAccounting/#_checkanddostakegoodaccounting","text":"function _checkAndDoStakeGoodAccounting(address staker, uint256 index, uint256 stakeId) internal checks that a stake is good accountable and runs goodAccounting if it is","title":"_checkAndDoStakeGoodAccounting"},{"location":"api/GoodAccounting/#parameters_5","text":"Name Type Description staker address the custodiann of the stake index uint256 the index of the stake id stakeId uint256 the stake id to be ended","title":"Parameters"},{"location":"api/GoodAccounting/#stakegoodaccounting","text":"function stakeGoodAccounting(address stakerAddr, uint256 stakeIndex, uint40 stakeIdParam) external freeze the progression of a stake to avoid penalties and preserve payout","title":"stakeGoodAccounting"},{"location":"api/GoodAccounting/#parameters_6","text":"Name Type Description stakerAddr address the originating stake address stakeIndex uint256 the index of the stake on the address stakeIdParam uint40 the stake id to verify the same stake is being targeted","title":"Parameters"},{"location":"api/GoodAccounting/#_stakegoodaccounting","text":"function _stakeGoodAccounting(address stakerAddr, uint256 stakeIndex, uint256 stakeIdParam) internal freeze the progression of a stake to avoid penalties and preserve payout","title":"_stakeGoodAccounting"},{"location":"api/GoodAccounting/#parameters_7","text":"Name Type Description stakerAddr address the originating stake address stakeIndex uint256 the index of the stake on the address stakeIdParam uint256 the stake id to verify the same stake is being targeted","title":"Parameters"},{"location":"api/HSIStakeManager/","text":"HSIStakeManager _defaultSettings function _defaultSettings() internal pure virtual returns (uint256) returns the default settings for a contract layer depositHsi function depositHsi(uint256 tokenId, uint256 encodedSettings) external payable returns (address hsiAddress) transfer stakes by their token ids requires approval to transfer hsi to this contract Parameters Name Type Description tokenId uint256 the token id to move to this contract encodedSettings uint256 _deposit721 function _deposit721(address token, uint256 tokenId) internal returns (address owner) deposit a tokenized hsi into this contract Parameters Name Type Description token address the address of the token (HSIM) tokenId uint256 the token id to deposit into this contract hsiAddressToId function hsiAddressToId(address hsiAddress) external view returns (uint256) a convenience method to retrieve a stake id from an hsi address Parameters Name Type Description hsiAddress address the hsi address to target _hsiAddressToId function _hsiAddressToId(address hsiAddress) internal view returns (uint256) an internal convenience method to retreive a stake id from an hsi address Parameters Name Type Description hsiAddress address the hsi address to target withdrawHsi function withdrawHsi(address hsiAddress) external payable returns (uint256 tokenId) withdraw an hsi from this contract's custody caller must be logged as owner of hsi Parameters Name Type Description hsiAddress address the hsi address to withdraw from this contract _hsiCount function _hsiCount(address staker) internal view returns (uint256 count) get the hsi count of a given stake owner Parameters Name Type Description staker address the account to check an hsi count _getStakeCount function _getStakeCount(address staker) internal view returns (uint256 count) get the count of stakes owned by a contract Parameters Name Type Description staker address the account to check how many stakes are owned _withdraw721 function _withdraw721(uint256 index, address owner, address hsiAddress) internal returns (uint256 tokenId) tokenize/mint a stake's erc721 token to transfer ownership of it Parameters Name Type Description index uint256 the index of the stake to tokenize owner address the owner of the stake hsiAddress address the hsi address (contract) that the stake is being custodied by _getStakeInfo function _getStakeInfo(uint256 stakeId) internal view returns (bool valid, address staker, uint256 stakeIndex, struct IUnderlyingStakeable.StakeStore stake) retrieve a stake id's (hsi address's) singular stake Parameters Name Type Description stakeId uint256 the stake id or hsi address to retrieve a stake from its list _stakeEnd function _stakeEnd(uint256 index, uint256 stakeId, uint256 hsiCountAfter) internal returns (uint256 targetReward) end a hsi's stake and return the amount of unattributed tokens sent to this contract Parameters Name Type Description index uint256 the hsim index of the stake to end stakeId uint256 the stake id or hsi address hsiCountAfter uint256 the length of stakes that will exist under the hsim after this end operation is complete _rewriteIndex function _rewriteIndex(uint256 index) internal because indexes change quickly they should be tracked and managed so that subsequent ends do not effect one another Parameters Name Type Description index uint256 the index to be targeted after removing an hsi from the underlying list _stakeStartFor function _stakeStartFor(address staker, uint256 newStakeAmount, uint256 newStakeDays, uint256 index) internal returns (uint256 stakeId) starts an hsi for the provided staker and saves its data appropriately Parameters Name Type Description staker address the staker that will own this stake newStakeAmount uint256 the number of tokens to add to the newly formed stake newStakeDays uint256 the number of days to stake said tokens for index uint256 the index of the stake in the list of all stakes _mintHedron function _mintHedron(uint256 index, uint256 stakeId) internal returns (uint256) mint hedron from an hsi Parameters Name Type Description index uint256 the index of the stake on hsim to mint stakeId uint256 the stake id or in this case, hsi address _checkStakeCustodian function _checkStakeCustodian(uint256 stakeId) internal view check that this contract is the custodian of this hsi (nft was depostied and detokenized) Parameters Name Type Description stakeId uint256 the stake id to check ownership over","title":"HSIStakeManager"},{"location":"api/HSIStakeManager/#hsistakemanager","text":"","title":"HSIStakeManager"},{"location":"api/HSIStakeManager/#_defaultsettings","text":"function _defaultSettings() internal pure virtual returns (uint256) returns the default settings for a contract layer","title":"_defaultSettings"},{"location":"api/HSIStakeManager/#deposithsi","text":"function depositHsi(uint256 tokenId, uint256 encodedSettings) external payable returns (address hsiAddress) transfer stakes by their token ids requires approval to transfer hsi to this contract","title":"depositHsi"},{"location":"api/HSIStakeManager/#parameters","text":"Name Type Description tokenId uint256 the token id to move to this contract encodedSettings uint256","title":"Parameters"},{"location":"api/HSIStakeManager/#_deposit721","text":"function _deposit721(address token, uint256 tokenId) internal returns (address owner) deposit a tokenized hsi into this contract","title":"_deposit721"},{"location":"api/HSIStakeManager/#parameters_1","text":"Name Type Description token address the address of the token (HSIM) tokenId uint256 the token id to deposit into this contract","title":"Parameters"},{"location":"api/HSIStakeManager/#hsiaddresstoid","text":"function hsiAddressToId(address hsiAddress) external view returns (uint256) a convenience method to retrieve a stake id from an hsi address","title":"hsiAddressToId"},{"location":"api/HSIStakeManager/#parameters_2","text":"Name Type Description hsiAddress address the hsi address to target","title":"Parameters"},{"location":"api/HSIStakeManager/#_hsiaddresstoid","text":"function _hsiAddressToId(address hsiAddress) internal view returns (uint256) an internal convenience method to retreive a stake id from an hsi address","title":"_hsiAddressToId"},{"location":"api/HSIStakeManager/#parameters_3","text":"Name Type Description hsiAddress address the hsi address to target","title":"Parameters"},{"location":"api/HSIStakeManager/#withdrawhsi","text":"function withdrawHsi(address hsiAddress) external payable returns (uint256 tokenId) withdraw an hsi from this contract's custody caller must be logged as owner of hsi","title":"withdrawHsi"},{"location":"api/HSIStakeManager/#parameters_4","text":"Name Type Description hsiAddress address the hsi address to withdraw from this contract","title":"Parameters"},{"location":"api/HSIStakeManager/#_hsicount","text":"function _hsiCount(address staker) internal view returns (uint256 count) get the hsi count of a given stake owner","title":"_hsiCount"},{"location":"api/HSIStakeManager/#parameters_5","text":"Name Type Description staker address the account to check an hsi count","title":"Parameters"},{"location":"api/HSIStakeManager/#_getstakecount","text":"function _getStakeCount(address staker) internal view returns (uint256 count) get the count of stakes owned by a contract","title":"_getStakeCount"},{"location":"api/HSIStakeManager/#parameters_6","text":"Name Type Description staker address the account to check how many stakes are owned","title":"Parameters"},{"location":"api/HSIStakeManager/#_withdraw721","text":"function _withdraw721(uint256 index, address owner, address hsiAddress) internal returns (uint256 tokenId) tokenize/mint a stake's erc721 token to transfer ownership of it","title":"_withdraw721"},{"location":"api/HSIStakeManager/#parameters_7","text":"Name Type Description index uint256 the index of the stake to tokenize owner address the owner of the stake hsiAddress address the hsi address (contract) that the stake is being custodied by","title":"Parameters"},{"location":"api/HSIStakeManager/#_getstakeinfo","text":"function _getStakeInfo(uint256 stakeId) internal view returns (bool valid, address staker, uint256 stakeIndex, struct IUnderlyingStakeable.StakeStore stake) retrieve a stake id's (hsi address's) singular stake","title":"_getStakeInfo"},{"location":"api/HSIStakeManager/#parameters_8","text":"Name Type Description stakeId uint256 the stake id or hsi address to retrieve a stake from its list","title":"Parameters"},{"location":"api/HSIStakeManager/#_stakeend","text":"function _stakeEnd(uint256 index, uint256 stakeId, uint256 hsiCountAfter) internal returns (uint256 targetReward) end a hsi's stake and return the amount of unattributed tokens sent to this contract","title":"_stakeEnd"},{"location":"api/HSIStakeManager/#parameters_9","text":"Name Type Description index uint256 the hsim index of the stake to end stakeId uint256 the stake id or hsi address hsiCountAfter uint256 the length of stakes that will exist under the hsim after this end operation is complete","title":"Parameters"},{"location":"api/HSIStakeManager/#_rewriteindex","text":"function _rewriteIndex(uint256 index) internal because indexes change quickly they should be tracked and managed so that subsequent ends do not effect one another","title":"_rewriteIndex"},{"location":"api/HSIStakeManager/#parameters_10","text":"Name Type Description index uint256 the index to be targeted after removing an hsi from the underlying list","title":"Parameters"},{"location":"api/HSIStakeManager/#_stakestartfor","text":"function _stakeStartFor(address staker, uint256 newStakeAmount, uint256 newStakeDays, uint256 index) internal returns (uint256 stakeId) starts an hsi for the provided staker and saves its data appropriately","title":"_stakeStartFor"},{"location":"api/HSIStakeManager/#parameters_11","text":"Name Type Description staker address the staker that will own this stake newStakeAmount uint256 the number of tokens to add to the newly formed stake newStakeDays uint256 the number of days to stake said tokens for index uint256 the index of the stake in the list of all stakes","title":"Parameters"},{"location":"api/HSIStakeManager/#_minthedron","text":"function _mintHedron(uint256 index, uint256 stakeId) internal returns (uint256) mint hedron from an hsi","title":"_mintHedron"},{"location":"api/HSIStakeManager/#parameters_12","text":"Name Type Description index uint256 the index of the stake on hsim to mint stakeId uint256 the stake id or in this case, hsi address","title":"Parameters"},{"location":"api/HSIStakeManager/#_checkstakecustodian","text":"function _checkStakeCustodian(uint256 stakeId) internal view check that this contract is the custodian of this hsi (nft was depostied and detokenized)","title":"_checkStakeCustodian"},{"location":"api/HSIStakeManager/#parameters_13","text":"Name Type Description stakeId uint256 the stake id to check ownership over","title":"Parameters"},{"location":"api/IsolatedStakeManager/","text":"IsolatedStakeManager constructor constructor(address account) public setAuthorization function setAuthorization(address account, uint256 settings) external set authorization flags for a provided target Parameters Name Type Description account address the address to change settings for settings uint256 the encoded setting (binary) to apply to the target address setStartAuthorization function setStartAuthorization(address runner, uint16 stakeDays, uint256 settings) external allow addresses to start stakes from tokens already in the contract Parameters Name Type Description runner address the anticipated address(es) that will be running the following method stakeDays uint16 the number of days that can be passed for the address (to constrain griefing) settings uint256 the settings to provide (only index 0 is relevant) startAuthorizationKey function startAuthorizationKey(address runner, uint256 stakeDays) external pure returns (bytes32) gets the start authorization key given a runner and stake days Parameters Name Type Description runner address the anticipated address(es) that will be running the following method stakeDays uint256 the number of days that can be passed for the address (to constrain griefing) stakeStart function stakeStart(uint256 newStakedHearts, uint256 newStakedDays) external stake a given amount of tokens for a given number of days if 0 is provided then the balance of the contract will be utilized this should generally only be used if tokens are sent to the contract and end stakes are not occuring for a number of days if you do not have global start abilities, but do have scoped abilities it is not rational to pass anything but zero for this method Parameters Name Type Description newStakedHearts uint256 the number of hearts to stake newStakedDays uint256 the number of days to stake said hearts stakeStartWithAuthorization function stakeStartWithAuthorization(uint256 newStakedDays) external start a stakes, so long as sender has the authorization to do so from owner Parameters Name Type Description newStakedDays uint256 the number of days to start a stake transferFromOwner function transferFromOwner(uint256 newStakedHearts) external transfer a number of hearts from the owner into the contract authorization occurs inside of the internal method Parameters Name Type Description newStakedHearts uint256 number of hearts to deposit into contract stakeEnd function stakeEnd(uint256 stakeIndex, uint40 stakeId) external ends the stake on the underlying target contract (HEX) and transfers tokens to the owner this method fails if the stake at the provided index does not match the stakeId Parameters Name Type Description stakeIndex uint256 the index of the stake in ownership list stakeId uint40 the id held on the stake transferToOwner function transferToOwner() external payable transfers tokens to the owner of the contract checkAndStakeEnd function checkAndStakeEnd(uint256 stakeIndex, uint40 stakeId) external ends the stake on the underlying target contract (HEX) and transfers tokens to the owner this method does not fail if the stake at the provided index does not have the provided stake id this method does not fail if authorization is not provided to the runner of this method this is to give every opportunity for strangers (who are authorized) to end stakes without risk of losing too much gas money Parameters Name Type Description stakeIndex uint256 the index of the stake in ownership list stakeId uint40 the id held on the stake _endStake function _endStake(uint256 stakeIndex, uint40 stakeId) internal ends a stake on the underlying contract this will fail on the underlying if the stakeIndex and stakeId does not match Parameters Name Type Description stakeIndex uint256 stake index to end stakeId uint40 stake id to end _transferToOwner function _transferToOwner() internal transfer balance to the owner of this contract _settingsCheck function _settingsCheck(struct IUnderlyingStakeable.StakeStore stake) internal view returns (bool) check the settings of the running address Parameters Name Type Description stake struct IUnderlyingStakeable.StakeStore the stake to check authorization over _startAuthorizationKey function _startAuthorizationKey(address runner, uint256 stakeDays) internal pure returns (bytes32) get the start authorization key for an address and number of stake days Parameters Name Type Description runner address the address that will run the method stakeDays uint256 the number of days to stake _stakeStart function _stakeStart(uint256 newStakedDays) internal starts a stake on the underlying contract for a given number of days Parameters Name Type Description newStakedDays uint256 a number of days to start a stake for _transferFromOwner function _transferFromOwner(uint256 amount) internal transfer a number of hearts from the owner to this contract Parameters Name Type Description amount uint256 number of hearts to transfer from owner","title":"IsolatedStakeManager"},{"location":"api/IsolatedStakeManager/#isolatedstakemanager","text":"","title":"IsolatedStakeManager"},{"location":"api/IsolatedStakeManager/#constructor","text":"constructor(address account) public","title":"constructor"},{"location":"api/IsolatedStakeManager/#setauthorization","text":"function setAuthorization(address account, uint256 settings) external set authorization flags for a provided target","title":"setAuthorization"},{"location":"api/IsolatedStakeManager/#parameters","text":"Name Type Description account address the address to change settings for settings uint256 the encoded setting (binary) to apply to the target address","title":"Parameters"},{"location":"api/IsolatedStakeManager/#setstartauthorization","text":"function setStartAuthorization(address runner, uint16 stakeDays, uint256 settings) external allow addresses to start stakes from tokens already in the contract","title":"setStartAuthorization"},{"location":"api/IsolatedStakeManager/#parameters_1","text":"Name Type Description runner address the anticipated address(es) that will be running the following method stakeDays uint16 the number of days that can be passed for the address (to constrain griefing) settings uint256 the settings to provide (only index 0 is relevant)","title":"Parameters"},{"location":"api/IsolatedStakeManager/#startauthorizationkey","text":"function startAuthorizationKey(address runner, uint256 stakeDays) external pure returns (bytes32) gets the start authorization key given a runner and stake days","title":"startAuthorizationKey"},{"location":"api/IsolatedStakeManager/#parameters_2","text":"Name Type Description runner address the anticipated address(es) that will be running the following method stakeDays uint256 the number of days that can be passed for the address (to constrain griefing)","title":"Parameters"},{"location":"api/IsolatedStakeManager/#stakestart","text":"function stakeStart(uint256 newStakedHearts, uint256 newStakedDays) external stake a given amount of tokens for a given number of days if 0 is provided then the balance of the contract will be utilized this should generally only be used if tokens are sent to the contract and end stakes are not occuring for a number of days if you do not have global start abilities, but do have scoped abilities it is not rational to pass anything but zero for this method","title":"stakeStart"},{"location":"api/IsolatedStakeManager/#parameters_3","text":"Name Type Description newStakedHearts uint256 the number of hearts to stake newStakedDays uint256 the number of days to stake said hearts","title":"Parameters"},{"location":"api/IsolatedStakeManager/#stakestartwithauthorization","text":"function stakeStartWithAuthorization(uint256 newStakedDays) external start a stakes, so long as sender has the authorization to do so from owner","title":"stakeStartWithAuthorization"},{"location":"api/IsolatedStakeManager/#parameters_4","text":"Name Type Description newStakedDays uint256 the number of days to start a stake","title":"Parameters"},{"location":"api/IsolatedStakeManager/#transferfromowner","text":"function transferFromOwner(uint256 newStakedHearts) external transfer a number of hearts from the owner into the contract authorization occurs inside of the internal method","title":"transferFromOwner"},{"location":"api/IsolatedStakeManager/#parameters_5","text":"Name Type Description newStakedHearts uint256 number of hearts to deposit into contract","title":"Parameters"},{"location":"api/IsolatedStakeManager/#stakeend","text":"function stakeEnd(uint256 stakeIndex, uint40 stakeId) external ends the stake on the underlying target contract (HEX) and transfers tokens to the owner this method fails if the stake at the provided index does not match the stakeId","title":"stakeEnd"},{"location":"api/IsolatedStakeManager/#parameters_6","text":"Name Type Description stakeIndex uint256 the index of the stake in ownership list stakeId uint40 the id held on the stake","title":"Parameters"},{"location":"api/IsolatedStakeManager/#transfertoowner","text":"function transferToOwner() external payable transfers tokens to the owner of the contract","title":"transferToOwner"},{"location":"api/IsolatedStakeManager/#checkandstakeend","text":"function checkAndStakeEnd(uint256 stakeIndex, uint40 stakeId) external ends the stake on the underlying target contract (HEX) and transfers tokens to the owner this method does not fail if the stake at the provided index does not have the provided stake id this method does not fail if authorization is not provided to the runner of this method this is to give every opportunity for strangers (who are authorized) to end stakes without risk of losing too much gas money","title":"checkAndStakeEnd"},{"location":"api/IsolatedStakeManager/#parameters_7","text":"Name Type Description stakeIndex uint256 the index of the stake in ownership list stakeId uint40 the id held on the stake","title":"Parameters"},{"location":"api/IsolatedStakeManager/#_endstake","text":"function _endStake(uint256 stakeIndex, uint40 stakeId) internal ends a stake on the underlying contract this will fail on the underlying if the stakeIndex and stakeId does not match","title":"_endStake"},{"location":"api/IsolatedStakeManager/#parameters_8","text":"Name Type Description stakeIndex uint256 stake index to end stakeId uint40 stake id to end","title":"Parameters"},{"location":"api/IsolatedStakeManager/#_transfertoowner","text":"function _transferToOwner() internal transfer balance to the owner of this contract","title":"_transferToOwner"},{"location":"api/IsolatedStakeManager/#_settingscheck","text":"function _settingsCheck(struct IUnderlyingStakeable.StakeStore stake) internal view returns (bool) check the settings of the running address","title":"_settingsCheck"},{"location":"api/IsolatedStakeManager/#parameters_9","text":"Name Type Description stake struct IUnderlyingStakeable.StakeStore the stake to check authorization over","title":"Parameters"},{"location":"api/IsolatedStakeManager/#_startauthorizationkey","text":"function _startAuthorizationKey(address runner, uint256 stakeDays) internal pure returns (bytes32) get the start authorization key for an address and number of stake days","title":"_startAuthorizationKey"},{"location":"api/IsolatedStakeManager/#parameters_10","text":"Name Type Description runner address the address that will run the method stakeDays uint256 the number of days to stake","title":"Parameters"},{"location":"api/IsolatedStakeManager/#_stakestart","text":"function _stakeStart(uint256 newStakedDays) internal starts a stake on the underlying contract for a given number of days","title":"_stakeStart"},{"location":"api/IsolatedStakeManager/#parameters_11","text":"Name Type Description newStakedDays uint256 a number of days to start a stake for","title":"Parameters"},{"location":"api/IsolatedStakeManager/#_transferfromowner","text":"function _transferFromOwner(uint256 amount) internal transfer a number of hearts from the owner to this contract","title":"_transferFromOwner"},{"location":"api/IsolatedStakeManager/#parameters_12","text":"Name Type Description amount uint256 number of hearts to transfer from owner","title":"Parameters"},{"location":"api/IsolatedStakeManagerFactory/","text":"IsolatedStakeManagerFactory CreateIsolatedStakeManager event CreateIsolatedStakeManager(address owner, address instance) isolatedStakeManagers mapping(address => address) isolatedStakeManagers a mapping of a key that contains a modifier and the owning address pointing to the address of the contract created by the stake manager createIsolatedManager function createIsolatedManager(address staker) external payable returns (address existing)","title":"IsolatedStakeManagerFactory"},{"location":"api/IsolatedStakeManagerFactory/#isolatedstakemanagerfactory","text":"","title":"IsolatedStakeManagerFactory"},{"location":"api/IsolatedStakeManagerFactory/#createisolatedstakemanager","text":"event CreateIsolatedStakeManager(address owner, address instance)","title":"CreateIsolatedStakeManager"},{"location":"api/IsolatedStakeManagerFactory/#isolatedstakemanagers","text":"mapping(address => address) isolatedStakeManagers a mapping of a key that contains a modifier and the owning address pointing to the address of the contract created by the stake manager","title":"isolatedStakeManagers"},{"location":"api/IsolatedStakeManagerFactory/#createisolatedmanager","text":"function createIsolatedManager(address staker) external payable returns (address existing)","title":"createIsolatedManager"},{"location":"api/Magnitude/","text":"Magnitude X_OPTIONS uint256 X_OPTIONS _computeDayMagnitude function _computeDayMagnitude(uint256 limit, uint256 method, uint256 x, uint256 today, uint256 lockedDay, uint256 stakedDays) internal pure returns (uint256 newMethod, uint256 numDays) _computeMagnitude function _computeMagnitude(uint256 limit, uint256 linear, uint256 v2, uint256 v1) internal pure returns (uint256 amount) compute a useful value from 2 inputs funds may never be linked to x variable. X should only hold data that we can plug into an expression to tell us where to land on the plot. Result is never less than 0, nor greater than limit Parameters Name Type Description limit uint256 linear uint256 holds the linear data to describe how to plot a provied y value v2 uint256 a secondary magnitude to use - generally the amount of the end stake v1 uint256 the starting point of v2 used for deltas _getDelta function _getDelta(uint256 method, uint256 v2, uint256 v1) internal pure returns (uint256 y) Linear struct Linear { uint256 method; uint256 xFactor; int256 x; uint256 yFactor; uint256 y; uint256 bFactor; int256 b; } _decodeLinear function _decodeLinear(uint256 encodedLinear) internal pure returns (struct Magnitude.Linear linear) computeMagnitude function computeMagnitude(uint256 limit, uint256 linear, uint256 v2, uint256 v1) external pure returns (uint256 result) compute a magnitude given an x and y Parameters Name Type Description limit uint256 a limit that the uint result can not be greater than linear uint256 the linear data to describe an (x/y)+b relationship v2 uint256 the second value as input v1 uint256 the stake to use as an input for the second value computeDayMagnitude function computeDayMagnitude(uint256 limit, uint256 method, uint256 x, uint256 today, uint256 lockedDay, uint256 stakedDays) external pure returns (uint256 newMethod, uint256 numDays) compute a day magnitude given an x and y Parameters Name Type Description limit uint256 a limit that the uint result can not be greater than method uint256 the method to use to compute the result x uint256 the first value as input today uint256 the hex day value lockedDay uint256 the day that the stake was locked stakedDays uint256 the number of full days that the stake was locked","title":"Magnitude"},{"location":"api/Magnitude/#magnitude","text":"","title":"Magnitude"},{"location":"api/Magnitude/#x_options","text":"uint256 X_OPTIONS","title":"X_OPTIONS"},{"location":"api/Magnitude/#_computedaymagnitude","text":"function _computeDayMagnitude(uint256 limit, uint256 method, uint256 x, uint256 today, uint256 lockedDay, uint256 stakedDays) internal pure returns (uint256 newMethod, uint256 numDays)","title":"_computeDayMagnitude"},{"location":"api/Magnitude/#_computemagnitude","text":"function _computeMagnitude(uint256 limit, uint256 linear, uint256 v2, uint256 v1) internal pure returns (uint256 amount) compute a useful value from 2 inputs funds may never be linked to x variable. X should only hold data that we can plug into an expression to tell us where to land on the plot. Result is never less than 0, nor greater than limit","title":"_computeMagnitude"},{"location":"api/Magnitude/#parameters","text":"Name Type Description limit uint256 linear uint256 holds the linear data to describe how to plot a provied y value v2 uint256 a secondary magnitude to use - generally the amount of the end stake v1 uint256 the starting point of v2 used for deltas","title":"Parameters"},{"location":"api/Magnitude/#_getdelta","text":"function _getDelta(uint256 method, uint256 v2, uint256 v1) internal pure returns (uint256 y)","title":"_getDelta"},{"location":"api/Magnitude/#linear","text":"struct Linear { uint256 method; uint256 xFactor; int256 x; uint256 yFactor; uint256 y; uint256 bFactor; int256 b; }","title":"Linear"},{"location":"api/Magnitude/#_decodelinear","text":"function _decodeLinear(uint256 encodedLinear) internal pure returns (struct Magnitude.Linear linear)","title":"_decodeLinear"},{"location":"api/Magnitude/#computemagnitude","text":"function computeMagnitude(uint256 limit, uint256 linear, uint256 v2, uint256 v1) external pure returns (uint256 result) compute a magnitude given an x and y","title":"computeMagnitude"},{"location":"api/Magnitude/#parameters_1","text":"Name Type Description limit uint256 a limit that the uint result can not be greater than linear uint256 the linear data to describe an (x/y)+b relationship v2 uint256 the second value as input v1 uint256 the stake to use as an input for the second value","title":"Parameters"},{"location":"api/Magnitude/#computedaymagnitude","text":"function computeDayMagnitude(uint256 limit, uint256 method, uint256 x, uint256 today, uint256 lockedDay, uint256 stakedDays) external pure returns (uint256 newMethod, uint256 numDays) compute a day magnitude given an x and y","title":"computeDayMagnitude"},{"location":"api/Magnitude/#parameters_2","text":"Name Type Description limit uint256 a limit that the uint result can not be greater than method uint256 the method to use to compute the result x uint256 the first value as input today uint256 the hex day value lockedDay uint256 the day that the stake was locked stakedDays uint256 the number of full days that the stake was locked","title":"Parameters"},{"location":"api/MaximusStakeManager/","text":"MaximusStakeManager externalPerpetualSetter address externalPerpetualSetter the address that can set the external perpetual filter contract address externalPerpetualFilter address externalPerpetualFilter a contract to consult regarding whether or not a given address is a perpetual pool perpetualWhitelist mapping(address => bool) perpetualWhitelist a whitelist for caching perpetual reads rewardsTo mapping(address => mapping(uint256 => address)) rewardsTo bytes32 is a key made up of the perpetual whitelist address + the iteration of the stake found at AddPerpetual event AddPerpetual(address perpetual) emitted when a contract is added to the whitelist Parameters Name Type Description perpetual address the perpetual contract added to the whitelist CollectReward event CollectReward(address perpetual, uint256 period, address token, uint256 amount) collect a reward from a given perpetual within a period Parameters Name Type Description perpetual address the perpetual contract being targeted period uint256 the period, managed internally by the perpetual token address the token being rewarded amount uint256 the amount of a token being rewarded constructor constructor() public a list of known perpetual contracts is set during constructor setExternalPerpetualFilter function setExternalPerpetualFilter(address _externalPerpetualFilter) external payable sets the extended perpetual filter to allow for other perpetual contracts to pass through the filter and added at a later date Parameters Name Type Description _externalPerpetualFilter address the extended perpetual filter set by the creator of this contract checkPerpetual function checkPerpetual(address perpetual) external payable returns (bool) check if a given contract can pass through the perpetual filter Parameters Name Type Description perpetual address the perpetual contract to check Return Values Name Type Description [0] bool isPerpetual when address has passed through the filter or extended filter _checkPerpetual function _checkPerpetual(address perpetual) internal returns (bool) check if a given contract can pass through the perpetual filter Parameters Name Type Description perpetual address the perpetual contract to check Return Values Name Type Description [0] bool isPerpetual when address has passed through the filter or extended filter after passing through extended filter, the result is cached _addPerpetual function _addPerpetual(address perpetual) internal adds new perpetual contract to the whitelist Once a perpetual is whitelisted it cannot be removed Parameters Name Type Description perpetual address the perpetual address to add to the persistent mapping stakeEndAs function stakeEndAs(address rewarded, bool v2, address perpetual, uint256 stakeId) external payable end a stake on a known perpetual Parameters Name Type Description rewarded address the address to reward with tokens v2 bool perpetual address the perpetual to end a stake on stakeId uint256 the stake id to end _checkEndable function _checkEndable(contract PublicEndStakeable endable) internal view returns (bool isEndable) checks if a given perpetual is endable Parameters Name Type Description endable contract PublicEndStakeable the endable perpetual contract Return Values Name Type Description isEndable bool denotes whether or not the stake is endable checkEndable function checkEndable(address endable) external view returns (bool) checks if a given perpetual is endable Parameters Name Type Description endable address the endable perpetual contract Return Values Name Type Description [0] bool isEndable verifies that the provided address is endable flush function flush(address gasReimberser, address perpetual, uint256 period, address[] tokens) external payable flush erc20 tokens into this contract this assumes that only one token is flushed at a time accounting will be lost if this patterns is broken by distribution tokens or perpetual sending more than one token at a time this method should not be chained to a stake end - it should be done in a separate transaction Parameters Name Type Description gasReimberser address the address to collect gas reimbursement from perpetual address the perpetual pool to call flush on period uint256 the period that the token collects against tokens address[] the token addresses to flush into this contract","title":"MaximusStakeManager"},{"location":"api/MaximusStakeManager/#maximusstakemanager","text":"","title":"MaximusStakeManager"},{"location":"api/MaximusStakeManager/#externalperpetualsetter","text":"address externalPerpetualSetter the address that can set the external perpetual filter contract address","title":"externalPerpetualSetter"},{"location":"api/MaximusStakeManager/#externalperpetualfilter","text":"address externalPerpetualFilter a contract to consult regarding whether or not a given address is a perpetual pool","title":"externalPerpetualFilter"},{"location":"api/MaximusStakeManager/#perpetualwhitelist","text":"mapping(address => bool) perpetualWhitelist a whitelist for caching perpetual reads","title":"perpetualWhitelist"},{"location":"api/MaximusStakeManager/#rewardsto","text":"mapping(address => mapping(uint256 => address)) rewardsTo bytes32 is a key made up of the perpetual whitelist address + the iteration of the stake found at","title":"rewardsTo"},{"location":"api/MaximusStakeManager/#addperpetual","text":"event AddPerpetual(address perpetual) emitted when a contract is added to the whitelist","title":"AddPerpetual"},{"location":"api/MaximusStakeManager/#parameters","text":"Name Type Description perpetual address the perpetual contract added to the whitelist","title":"Parameters"},{"location":"api/MaximusStakeManager/#collectreward","text":"event CollectReward(address perpetual, uint256 period, address token, uint256 amount) collect a reward from a given perpetual within a period","title":"CollectReward"},{"location":"api/MaximusStakeManager/#parameters_1","text":"Name Type Description perpetual address the perpetual contract being targeted period uint256 the period, managed internally by the perpetual token address the token being rewarded amount uint256 the amount of a token being rewarded","title":"Parameters"},{"location":"api/MaximusStakeManager/#constructor","text":"constructor() public a list of known perpetual contracts is set during constructor","title":"constructor"},{"location":"api/MaximusStakeManager/#setexternalperpetualfilter","text":"function setExternalPerpetualFilter(address _externalPerpetualFilter) external payable sets the extended perpetual filter to allow for other perpetual contracts to pass through the filter and added at a later date","title":"setExternalPerpetualFilter"},{"location":"api/MaximusStakeManager/#parameters_2","text":"Name Type Description _externalPerpetualFilter address the extended perpetual filter set by the creator of this contract","title":"Parameters"},{"location":"api/MaximusStakeManager/#checkperpetual","text":"function checkPerpetual(address perpetual) external payable returns (bool) check if a given contract can pass through the perpetual filter","title":"checkPerpetual"},{"location":"api/MaximusStakeManager/#parameters_3","text":"Name Type Description perpetual address the perpetual contract to check","title":"Parameters"},{"location":"api/MaximusStakeManager/#return-values","text":"Name Type Description [0] bool isPerpetual when address has passed through the filter or extended filter","title":"Return Values"},{"location":"api/MaximusStakeManager/#_checkperpetual","text":"function _checkPerpetual(address perpetual) internal returns (bool) check if a given contract can pass through the perpetual filter","title":"_checkPerpetual"},{"location":"api/MaximusStakeManager/#parameters_4","text":"Name Type Description perpetual address the perpetual contract to check","title":"Parameters"},{"location":"api/MaximusStakeManager/#return-values_1","text":"Name Type Description [0] bool isPerpetual when address has passed through the filter or extended filter after passing through extended filter, the result is cached","title":"Return Values"},{"location":"api/MaximusStakeManager/#_addperpetual","text":"function _addPerpetual(address perpetual) internal adds new perpetual contract to the whitelist Once a perpetual is whitelisted it cannot be removed","title":"_addPerpetual"},{"location":"api/MaximusStakeManager/#parameters_5","text":"Name Type Description perpetual address the perpetual address to add to the persistent mapping","title":"Parameters"},{"location":"api/MaximusStakeManager/#stakeendas","text":"function stakeEndAs(address rewarded, bool v2, address perpetual, uint256 stakeId) external payable end a stake on a known perpetual","title":"stakeEndAs"},{"location":"api/MaximusStakeManager/#parameters_6","text":"Name Type Description rewarded address the address to reward with tokens v2 bool perpetual address the perpetual to end a stake on stakeId uint256 the stake id to end","title":"Parameters"},{"location":"api/MaximusStakeManager/#_checkendable","text":"function _checkEndable(contract PublicEndStakeable endable) internal view returns (bool isEndable) checks if a given perpetual is endable","title":"_checkEndable"},{"location":"api/MaximusStakeManager/#parameters_7","text":"Name Type Description endable contract PublicEndStakeable the endable perpetual contract","title":"Parameters"},{"location":"api/MaximusStakeManager/#return-values_2","text":"Name Type Description isEndable bool denotes whether or not the stake is endable","title":"Return Values"},{"location":"api/MaximusStakeManager/#checkendable","text":"function checkEndable(address endable) external view returns (bool) checks if a given perpetual is endable","title":"checkEndable"},{"location":"api/MaximusStakeManager/#parameters_8","text":"Name Type Description endable address the endable perpetual contract","title":"Parameters"},{"location":"api/MaximusStakeManager/#return-values_3","text":"Name Type Description [0] bool isEndable verifies that the provided address is endable","title":"Return Values"},{"location":"api/MaximusStakeManager/#flush","text":"function flush(address gasReimberser, address perpetual, uint256 period, address[] tokens) external payable flush erc20 tokens into this contract this assumes that only one token is flushed at a time accounting will be lost if this patterns is broken by distribution tokens or perpetual sending more than one token at a time this method should not be chained to a stake end - it should be done in a separate transaction","title":"flush"},{"location":"api/MaximusStakeManager/#parameters_9","text":"Name Type Description gasReimberser address the address to collect gas reimbursement from perpetual address the perpetual pool to call flush on period uint256 the period that the token collects against tokens address[] the token addresses to flush into this contract","title":"Parameters"},{"location":"api/MulticallExtension/","text":"MulticallExtension this multicall extension is useful for chaining permissioned calls in other words, calls that operate on the senders funds or settings BlockHash error BlockHash(bytes32 expected, bytes32 actual) OutsideTimestamps error OutsideTimestamps(uint256 minTime, uint256 maxTime, uint256 currentTime) TxFailed event TxFailed(uint256 index, bytes result) multicall function multicall(bytes[] calls, bool allowFailures) external call a series of functions on a contract that inherits this method Parameters Name Type Description calls bytes[] the calls to perform on this contract allowFailures bool whether to allow failures or to error out multicallBetweenTimestamp function multicallBetweenTimestamp(uint256 minTime, uint256 maxTime, bytes[] calls, bool allowFailures) external call multiple methods and pass a deadline, after which the transaction should fail Parameters Name Type Description minTime uint256 the min valid timestamp, in seconds maxTime uint256 the max valid timestamp, in seconds calls bytes[] the calldata to run on the external method allowFailures bool allows failures when true multicallWithPreviousBlockHash function multicallWithPreviousBlockHash(bytes32 previousBlockhash, bytes[] calls, bool allowFailures) external pass the previous block hash to enable mev uncle bandit protection Parameters Name Type Description previousBlockhash bytes32 the previously mined block - useful for mev protected uncle bandit risks calls bytes[] the calldata to run on the external method allowFailures bool allows failures when true _multicall function _multicall(bytes[] calls, bool allowFailures) internal call multiple / arbitrary steps allowing each to fail independently or requiring all to succeed Parameters Name Type Description calls bytes[] the sequence of calls that is requested allowFailures bool allows the calls to fail separately or requires all to succeed or fail","title":"MulticallExtension"},{"location":"api/MulticallExtension/#multicallextension","text":"this multicall extension is useful for chaining permissioned calls in other words, calls that operate on the senders funds or settings","title":"MulticallExtension"},{"location":"api/MulticallExtension/#blockhash","text":"error BlockHash(bytes32 expected, bytes32 actual)","title":"BlockHash"},{"location":"api/MulticallExtension/#outsidetimestamps","text":"error OutsideTimestamps(uint256 minTime, uint256 maxTime, uint256 currentTime)","title":"OutsideTimestamps"},{"location":"api/MulticallExtension/#txfailed","text":"event TxFailed(uint256 index, bytes result)","title":"TxFailed"},{"location":"api/MulticallExtension/#multicall","text":"function multicall(bytes[] calls, bool allowFailures) external call a series of functions on a contract that inherits this method","title":"multicall"},{"location":"api/MulticallExtension/#parameters","text":"Name Type Description calls bytes[] the calls to perform on this contract allowFailures bool whether to allow failures or to error out","title":"Parameters"},{"location":"api/MulticallExtension/#multicallbetweentimestamp","text":"function multicallBetweenTimestamp(uint256 minTime, uint256 maxTime, bytes[] calls, bool allowFailures) external call multiple methods and pass a deadline, after which the transaction should fail","title":"multicallBetweenTimestamp"},{"location":"api/MulticallExtension/#parameters_1","text":"Name Type Description minTime uint256 the min valid timestamp, in seconds maxTime uint256 the max valid timestamp, in seconds calls bytes[] the calldata to run on the external method allowFailures bool allows failures when true","title":"Parameters"},{"location":"api/MulticallExtension/#multicallwithpreviousblockhash","text":"function multicallWithPreviousBlockHash(bytes32 previousBlockhash, bytes[] calls, bool allowFailures) external pass the previous block hash to enable mev uncle bandit protection","title":"multicallWithPreviousBlockHash"},{"location":"api/MulticallExtension/#parameters_2","text":"Name Type Description previousBlockhash bytes32 the previously mined block - useful for mev protected uncle bandit risks calls bytes[] the calldata to run on the external method allowFailures bool allows failures when true","title":"Parameters"},{"location":"api/MulticallExtension/#_multicall","text":"function _multicall(bytes[] calls, bool allowFailures) internal call multiple / arbitrary steps allowing each to fail independently or requiring all to succeed","title":"_multicall"},{"location":"api/MulticallExtension/#parameters_3","text":"Name Type Description calls bytes[] the sequence of calls that is requested allowFailures bool allows the calls to fail separately or requires all to succeed or fail","title":"Parameters"},{"location":"api/Ownable2Step/","text":"Ownable2Step a very short replacement for Ownable2Step from oz owner address owner pendingOwner address pendingOwner OnlyOwner error OnlyOwner() OwnershipTransferred event OwnershipTransferred(address previousOwner, address owner) OwnershipTransferStarted event OwnershipTransferStarted(address owner, address pendingOwner) _transferOwnership function _transferOwnership(address account) internal transferOwnership function transferOwnership(address account) external acceptOwnership function acceptOwnership() external _onlyOwner function _onlyOwner() internal view","title":"Ownable2Step"},{"location":"api/Ownable2Step/#ownable2step","text":"a very short replacement for Ownable2Step from oz","title":"Ownable2Step"},{"location":"api/Ownable2Step/#owner","text":"address owner","title":"owner"},{"location":"api/Ownable2Step/#pendingowner","text":"address pendingOwner","title":"pendingOwner"},{"location":"api/Ownable2Step/#onlyowner","text":"error OnlyOwner()","title":"OnlyOwner"},{"location":"api/Ownable2Step/#ownershiptransferred","text":"event OwnershipTransferred(address previousOwner, address owner)","title":"OwnershipTransferred"},{"location":"api/Ownable2Step/#ownershiptransferstarted","text":"event OwnershipTransferStarted(address owner, address pendingOwner)","title":"OwnershipTransferStarted"},{"location":"api/Ownable2Step/#_transferownership","text":"function _transferOwnership(address account) internal","title":"_transferOwnership"},{"location":"api/Ownable2Step/#transferownership","text":"function transferOwnership(address account) external","title":"transferOwnership"},{"location":"api/Ownable2Step/#acceptownership","text":"function acceptOwnership() external","title":"acceptOwnership"},{"location":"api/Ownable2Step/#_onlyowner","text":"function _onlyOwner() internal view","title":"_onlyOwner"},{"location":"api/SingletonCommunis/","text":"SingletonCommunis CommunisMintPortion enum CommunisMintPortion { START, GOOD_ACCOUNT, END } distributableCommunis uint256 distributableCommunis the total communis that is distributable to stakers formerStakeOwner mapping(uint256 => address) formerStakeOwner the former stake owner - must be tracked to constrain communis restakes after hex stake ends stakeIdCommunisPayoutInfo mapping(uint256 => uint256) stakeIdCommunisPayoutInfo stake id to encoded payout info NINETY_ONE uint256 NINETY_ONE the number of days after today when one can claim tokens after staking ONE_TWENTY uint256 ONE_TWENTY the bit placement index (from the left) of endBonusPayoutDebt TWO_FOURTY uint256 TWO_FOURTY the bit placement index of the anyEnded flag to signify that a stake has ever ended from this address mintCommunis function mintCommunis(enum SingletonCommunis.CommunisMintPortion portion, uint256 stakeId, address referrer, uint256 stakeAmount) external payable returns (uint256 amount) mint comm for staking during stake good accounting, stakeAmount is used as a boolean 1 = withdraw, anything else = custody in contract this function only works for non hsi's since stake is owned by other contract in that case Parameters Name Type Description portion enum SingletonCommunis.CommunisMintPortion an enum corresponding to a method to be called for minting $COMM stakeId uint256 the stake id to target - first call must be run by owner referrer address the referrer of the mint stakeAmount uint256 the amount of the start bonus to stake. the left-most bit designated as a boolean for applying restake bonus _setEndStakedSignal function _setEndStakedSignal() internal sets the end staked signal if it has not yet been set _encodePayoutInfo function _encodePayoutInfo(uint256 nextPayoutDay, uint256 endBonusPayoutDebt, uint256 stakeAmount, uint256 hasEnded) internal pure returns (uint256 encoded) track information regarding the state of payout for a single stake saving information like this allows for 1 SLOAD instead of multiple calls to the external/underlying contract and multiple SLOADs Parameters Name Type Description nextPayoutDay uint256 the next day that a distribution can occur for the linked stake id endBonusPayoutDebt uint256 the amount of debt that the end stake payout accrued. stakeAmount must never go below this number. value must fit within uint120 stakeAmount uint256 the amount staked by the linked stake id value must fit within uint119 hasEnded uint256 1/0 whether or not the stake has been ended it is simply easier to keep this in uint form because there are fewer required operations setFutureStakeEndCommunisAmount function setFutureStakeEndCommunisAmount(uint256 stakeId, uint256 futureEndStakeAmount) external payable sets a stake amount to use in the future - when the stake may be ended by others Parameters Name Type Description stakeId uint256 the stake id to target futureEndStakeAmount uint256 the amount to stake in the future 0 = stake it all, debt will be used as a staking floor _maxPayout function _maxPayout(struct IUnderlyingStakeable.StakeStore stake) internal pure returns (uint256) calculate the maximum payout that can be achieved by this stake - ignoring start bonus Parameters Name Type Description stake struct IUnderlyingStakeable.StakeStore the stake being ended Return Values Name Type Description [0] uint256 maxPayout the maximum payout that can be achieved by this stake _stakeAmountFromInputs function _stakeAmountFromInputs(uint256 requestedStakeAmount, address requestedReferrer, struct IUnderlyingStakeable.StakeStore stake) internal view returns (uint256 stakeAmount, address referrer, uint256 payout) Parameters Name Type Description requestedStakeAmount uint256 the requested stake amount from client may be untrustworthy so we will put it through some filters requestedReferrer address the referrer requested by the client stake struct IUnderlyingStakeable.StakeStore the stake struct that is being ended Return Values Name Type Description stakeAmount uint256 the stake amount to use, clamped to the payout as max and the debt as min referrer address the account that will receive funds payout uint256 the payout that is occuring as the maxPayout - start bonus payout which could have only been minted by the stake owner _communisStakeEndBonus function _communisStakeEndBonus(uint256 settings, uint256 today, uint256 index, address staker, address referrer, struct IUnderlyingStakeable.StakeStore stake) internal mint end bonus before ending a hex stake Parameters Name Type Description settings uint256 today uint256 index uint256 the index of the stake to find it in the stake list staker address the staker that will receive funds referrer address the referrer (tipTo) address stake struct IUnderlyingStakeable.StakeStore the in memory stake to use _verifyOnlyStaker function _verifyOnlyStaker(uint256 stakeId) internal view returns (address staker) check that the stake id is owned by the sender - fail if it is not Parameters Name Type Description stakeId uint256 the stake id to check that the sender is or was the owner withdrawCommunisByStakeId function withdrawCommunisByStakeId(uint256 withdrawAmount, uint256 stakeId, bool withdraw, address to) external payable returns (uint256) withdraws a stake up to the debt limit Parameters Name Type Description withdrawAmount uint256 the desired amount to withdraw - can be truncated if debt cannot cover stakeId uint256 the stake id to target - this is a permissioned method - caller must be owner or previous owner withdraw bool the funds should be withdrawn to the address, otherwise custodied by this contract to address mintStakeBonus function mintStakeBonus() external payable returns (bool anyEnded, uint256 currentDistributableCommunis) mint the stake bonus for the stake manager contract - useful for keeping accounting up to date _mintStakeBonus function _mintStakeBonus() internal returns (uint256 anyEnded, uint256 currentDistributableCommunis) claims stake bonus for everyone staking through stake manager contract Return Values Name Type Description anyEnded uint256 1/0 to signal that an end stake bonus has occurred currentDistributableCommunis uint256 the total bonus distributed to all stakers in this contract distributeCommunisStakeBonusByStakeId function distributeCommunisStakeBonusByStakeId(uint256 stakeId, bool withdraw, address to) external payable returns (uint256 payout) distribute communis stake bonus, given a stake id Parameters Name Type Description stakeId uint256 the stake id to use to apply limits to the distribution withdraw bool whether or not the funds should be transferred to the stake owner to address _distributeCommunisStakeBonusByStakeId function _distributeCommunisStakeBonusByStakeId(address to, bool withdraw, uint256 payoutInfo, uint256 day) internal returns (uint256 payout, uint256 nextPayoutInfo, uint256 anyEnded) _checkDistribute function _checkDistribute(uint256 anyEnded, uint256 payoutInfo, uint256 day) internal pure returns (bool canDistribute) check if a given set of payout info is available to be distributed to from stake Parameters Name Type Description anyEnded uint256 payoutInfo uint256 the payout info being checked for ability to distribute day uint256 the current hex day _doDistribute function _doDistribute(uint256 payoutInfo, uint256 day, address to, bool withdraw, uint256 anyEnded, uint256 currentDistributableCommunis) internal returns (uint256 payout, uint256 nextPayoutInfo) does the distribution for a given stake given their payout info Parameters Name Type Description payoutInfo uint256 the info tracked for payouts over time day uint256 the current hex day to address withdraw bool anyEnded uint256 currentDistributableCommunis uint256","title":"SingletonCommunis"},{"location":"api/SingletonCommunis/#singletoncommunis","text":"","title":"SingletonCommunis"},{"location":"api/SingletonCommunis/#communismintportion","text":"enum CommunisMintPortion { START, GOOD_ACCOUNT, END }","title":"CommunisMintPortion"},{"location":"api/SingletonCommunis/#distributablecommunis","text":"uint256 distributableCommunis the total communis that is distributable to stakers","title":"distributableCommunis"},{"location":"api/SingletonCommunis/#formerstakeowner","text":"mapping(uint256 => address) formerStakeOwner the former stake owner - must be tracked to constrain communis restakes after hex stake ends","title":"formerStakeOwner"},{"location":"api/SingletonCommunis/#stakeidcommunispayoutinfo","text":"mapping(uint256 => uint256) stakeIdCommunisPayoutInfo stake id to encoded payout info","title":"stakeIdCommunisPayoutInfo"},{"location":"api/SingletonCommunis/#ninety_one","text":"uint256 NINETY_ONE the number of days after today when one can claim tokens after staking","title":"NINETY_ONE"},{"location":"api/SingletonCommunis/#one_twenty","text":"uint256 ONE_TWENTY the bit placement index (from the left) of endBonusPayoutDebt","title":"ONE_TWENTY"},{"location":"api/SingletonCommunis/#two_fourty","text":"uint256 TWO_FOURTY the bit placement index of the anyEnded flag to signify that a stake has ever ended from this address","title":"TWO_FOURTY"},{"location":"api/SingletonCommunis/#mintcommunis","text":"function mintCommunis(enum SingletonCommunis.CommunisMintPortion portion, uint256 stakeId, address referrer, uint256 stakeAmount) external payable returns (uint256 amount) mint comm for staking during stake good accounting, stakeAmount is used as a boolean 1 = withdraw, anything else = custody in contract this function only works for non hsi's since stake is owned by other contract in that case","title":"mintCommunis"},{"location":"api/SingletonCommunis/#parameters","text":"Name Type Description portion enum SingletonCommunis.CommunisMintPortion an enum corresponding to a method to be called for minting $COMM stakeId uint256 the stake id to target - first call must be run by owner referrer address the referrer of the mint stakeAmount uint256 the amount of the start bonus to stake. the left-most bit designated as a boolean for applying restake bonus","title":"Parameters"},{"location":"api/SingletonCommunis/#_setendstakedsignal","text":"function _setEndStakedSignal() internal sets the end staked signal if it has not yet been set","title":"_setEndStakedSignal"},{"location":"api/SingletonCommunis/#_encodepayoutinfo","text":"function _encodePayoutInfo(uint256 nextPayoutDay, uint256 endBonusPayoutDebt, uint256 stakeAmount, uint256 hasEnded) internal pure returns (uint256 encoded) track information regarding the state of payout for a single stake saving information like this allows for 1 SLOAD instead of multiple calls to the external/underlying contract and multiple SLOADs","title":"_encodePayoutInfo"},{"location":"api/SingletonCommunis/#parameters_1","text":"Name Type Description nextPayoutDay uint256 the next day that a distribution can occur for the linked stake id endBonusPayoutDebt uint256 the amount of debt that the end stake payout accrued. stakeAmount must never go below this number. value must fit within uint120 stakeAmount uint256 the amount staked by the linked stake id value must fit within uint119 hasEnded uint256 1/0 whether or not the stake has been ended it is simply easier to keep this in uint form because there are fewer required operations","title":"Parameters"},{"location":"api/SingletonCommunis/#setfuturestakeendcommunisamount","text":"function setFutureStakeEndCommunisAmount(uint256 stakeId, uint256 futureEndStakeAmount) external payable sets a stake amount to use in the future - when the stake may be ended by others","title":"setFutureStakeEndCommunisAmount"},{"location":"api/SingletonCommunis/#parameters_2","text":"Name Type Description stakeId uint256 the stake id to target futureEndStakeAmount uint256 the amount to stake in the future 0 = stake it all, debt will be used as a staking floor","title":"Parameters"},{"location":"api/SingletonCommunis/#_maxpayout","text":"function _maxPayout(struct IUnderlyingStakeable.StakeStore stake) internal pure returns (uint256) calculate the maximum payout that can be achieved by this stake - ignoring start bonus","title":"_maxPayout"},{"location":"api/SingletonCommunis/#parameters_3","text":"Name Type Description stake struct IUnderlyingStakeable.StakeStore the stake being ended","title":"Parameters"},{"location":"api/SingletonCommunis/#return-values","text":"Name Type Description [0] uint256 maxPayout the maximum payout that can be achieved by this stake","title":"Return Values"},{"location":"api/SingletonCommunis/#_stakeamountfrominputs","text":"function _stakeAmountFromInputs(uint256 requestedStakeAmount, address requestedReferrer, struct IUnderlyingStakeable.StakeStore stake) internal view returns (uint256 stakeAmount, address referrer, uint256 payout)","title":"_stakeAmountFromInputs"},{"location":"api/SingletonCommunis/#parameters_4","text":"Name Type Description requestedStakeAmount uint256 the requested stake amount from client may be untrustworthy so we will put it through some filters requestedReferrer address the referrer requested by the client stake struct IUnderlyingStakeable.StakeStore the stake struct that is being ended","title":"Parameters"},{"location":"api/SingletonCommunis/#return-values_1","text":"Name Type Description stakeAmount uint256 the stake amount to use, clamped to the payout as max and the debt as min referrer address the account that will receive funds payout uint256 the payout that is occuring as the maxPayout - start bonus payout which could have only been minted by the stake owner","title":"Return Values"},{"location":"api/SingletonCommunis/#_communisstakeendbonus","text":"function _communisStakeEndBonus(uint256 settings, uint256 today, uint256 index, address staker, address referrer, struct IUnderlyingStakeable.StakeStore stake) internal mint end bonus before ending a hex stake","title":"_communisStakeEndBonus"},{"location":"api/SingletonCommunis/#parameters_5","text":"Name Type Description settings uint256 today uint256 index uint256 the index of the stake to find it in the stake list staker address the staker that will receive funds referrer address the referrer (tipTo) address stake struct IUnderlyingStakeable.StakeStore the in memory stake to use","title":"Parameters"},{"location":"api/SingletonCommunis/#_verifyonlystaker","text":"function _verifyOnlyStaker(uint256 stakeId) internal view returns (address staker) check that the stake id is owned by the sender - fail if it is not","title":"_verifyOnlyStaker"},{"location":"api/SingletonCommunis/#parameters_6","text":"Name Type Description stakeId uint256 the stake id to check that the sender is or was the owner","title":"Parameters"},{"location":"api/SingletonCommunis/#withdrawcommunisbystakeid","text":"function withdrawCommunisByStakeId(uint256 withdrawAmount, uint256 stakeId, bool withdraw, address to) external payable returns (uint256) withdraws a stake up to the debt limit","title":"withdrawCommunisByStakeId"},{"location":"api/SingletonCommunis/#parameters_7","text":"Name Type Description withdrawAmount uint256 the desired amount to withdraw - can be truncated if debt cannot cover stakeId uint256 the stake id to target - this is a permissioned method - caller must be owner or previous owner withdraw bool the funds should be withdrawn to the address, otherwise custodied by this contract to address","title":"Parameters"},{"location":"api/SingletonCommunis/#mintstakebonus","text":"function mintStakeBonus() external payable returns (bool anyEnded, uint256 currentDistributableCommunis) mint the stake bonus for the stake manager contract - useful for keeping accounting up to date","title":"mintStakeBonus"},{"location":"api/SingletonCommunis/#_mintstakebonus","text":"function _mintStakeBonus() internal returns (uint256 anyEnded, uint256 currentDistributableCommunis) claims stake bonus for everyone staking through stake manager contract","title":"_mintStakeBonus"},{"location":"api/SingletonCommunis/#return-values_2","text":"Name Type Description anyEnded uint256 1/0 to signal that an end stake bonus has occurred currentDistributableCommunis uint256 the total bonus distributed to all stakers in this contract","title":"Return Values"},{"location":"api/SingletonCommunis/#distributecommunisstakebonusbystakeid","text":"function distributeCommunisStakeBonusByStakeId(uint256 stakeId, bool withdraw, address to) external payable returns (uint256 payout) distribute communis stake bonus, given a stake id","title":"distributeCommunisStakeBonusByStakeId"},{"location":"api/SingletonCommunis/#parameters_8","text":"Name Type Description stakeId uint256 the stake id to use to apply limits to the distribution withdraw bool whether or not the funds should be transferred to the stake owner to address","title":"Parameters"},{"location":"api/SingletonCommunis/#_distributecommunisstakebonusbystakeid","text":"function _distributeCommunisStakeBonusByStakeId(address to, bool withdraw, uint256 payoutInfo, uint256 day) internal returns (uint256 payout, uint256 nextPayoutInfo, uint256 anyEnded)","title":"_distributeCommunisStakeBonusByStakeId"},{"location":"api/SingletonCommunis/#_checkdistribute","text":"function _checkDistribute(uint256 anyEnded, uint256 payoutInfo, uint256 day) internal pure returns (bool canDistribute) check if a given set of payout info is available to be distributed to from stake","title":"_checkDistribute"},{"location":"api/SingletonCommunis/#parameters_9","text":"Name Type Description anyEnded uint256 payoutInfo uint256 the payout info being checked for ability to distribute day uint256 the current hex day","title":"Parameters"},{"location":"api/SingletonCommunis/#_dodistribute","text":"function _doDistribute(uint256 payoutInfo, uint256 day, address to, bool withdraw, uint256 anyEnded, uint256 currentDistributableCommunis) internal returns (uint256 payout, uint256 nextPayoutInfo) does the distribution for a given stake given their payout info","title":"_doDistribute"},{"location":"api/SingletonCommunis/#parameters_10","text":"Name Type Description payoutInfo uint256 the info tracked for payouts over time day uint256 the current hex day to address withdraw bool anyEnded uint256 currentDistributableCommunis uint256","title":"Parameters"},{"location":"api/SingletonMintManager/","text":"SingletonMintManager createTo function createTo(uint256 settings, address owner) external pure returns (uint256 to) combine a boolean from a settings value and the owner address to reduce the number of transfers / writes that occur during a loop Parameters Name Type Description settings uint256 the settings to determine if a withdrawal should occur owner address the owner of the underlying stake Return Values Name Type Description to uint256 the uint256 representation of a single bit in settings and an owner address _createTo function _createTo(uint256 settings, address owner) internal pure returns (uint256 to) mintHedronRewards function mintHedronRewards(uint256[] stakeIds) external mint rewards and transfer them to a provided address any combination of owners can be passed, however, it is most efficient to order the hsi address by owner Parameters Name Type Description stakeIds uint256[] list of stake ids to mint _mintHedron function _mintHedron(uint256 index, uint256 stakeId) internal virtual returns (uint256 amount) mint native hedron for a given stake id Parameters Name Type Description index uint256 the index of the native stake to mint stakeId uint256 the stake id to mint _communisStakeEndBonus function _communisStakeEndBonus(uint256 settings, uint256 today, uint256 index, address staker, address referrer, struct IUnderlyingStakeable.StakeStore stake) internal virtual overridable noop method for minting end bonus before ending a hex stake Parameters Name Type Description settings uint256 the settings of the stake (just before it is ended) today uint256 the day as an int (currentDay from hex) index uint256 the index of the stake to find it in the stake list staker address the staker that will receive funds referrer address the referrer (tipTo) address stake struct IUnderlyingStakeable.StakeStore the in memory stake to use","title":"SingletonMintManager"},{"location":"api/SingletonMintManager/#singletonmintmanager","text":"","title":"SingletonMintManager"},{"location":"api/SingletonMintManager/#createto","text":"function createTo(uint256 settings, address owner) external pure returns (uint256 to) combine a boolean from a settings value and the owner address to reduce the number of transfers / writes that occur during a loop","title":"createTo"},{"location":"api/SingletonMintManager/#parameters","text":"Name Type Description settings uint256 the settings to determine if a withdrawal should occur owner address the owner of the underlying stake","title":"Parameters"},{"location":"api/SingletonMintManager/#return-values","text":"Name Type Description to uint256 the uint256 representation of a single bit in settings and an owner address","title":"Return Values"},{"location":"api/SingletonMintManager/#_createto","text":"function _createTo(uint256 settings, address owner) internal pure returns (uint256 to)","title":"_createTo"},{"location":"api/SingletonMintManager/#minthedronrewards","text":"function mintHedronRewards(uint256[] stakeIds) external mint rewards and transfer them to a provided address any combination of owners can be passed, however, it is most efficient to order the hsi address by owner","title":"mintHedronRewards"},{"location":"api/SingletonMintManager/#parameters_1","text":"Name Type Description stakeIds uint256[] list of stake ids to mint","title":"Parameters"},{"location":"api/SingletonMintManager/#_minthedron","text":"function _mintHedron(uint256 index, uint256 stakeId) internal virtual returns (uint256 amount) mint native hedron for a given stake id","title":"_mintHedron"},{"location":"api/SingletonMintManager/#parameters_2","text":"Name Type Description index uint256 the index of the native stake to mint stakeId uint256 the stake id to mint","title":"Parameters"},{"location":"api/SingletonMintManager/#_communisstakeendbonus","text":"function _communisStakeEndBonus(uint256 settings, uint256 today, uint256 index, address staker, address referrer, struct IUnderlyingStakeable.StakeStore stake) internal virtual overridable noop method for minting end bonus before ending a hex stake","title":"_communisStakeEndBonus"},{"location":"api/SingletonMintManager/#parameters_3","text":"Name Type Description settings uint256 the settings of the stake (just before it is ended) today uint256 the day as an int (currentDay from hex) index uint256 the index of the stake to find it in the stake list staker address the staker that will receive funds referrer address the referrer (tipTo) address stake struct IUnderlyingStakeable.StakeStore the in memory stake to use","title":"Parameters"},{"location":"api/StakeEnder/","text":"StakeEnder INDEX_RIGHT_TODAY uint256 INDEX_RIGHT_TODAY stakeEndByConsentWithTipTo function stakeEndByConsentWithTipTo(uint256 stakeId, address tipTo) external payable returns (bool) end a stake, given its settings, and tip to a given address Parameters Name Type Description stakeId uint256 the stake id being targeted for ending tipTo address where to send tokens from tips Return Values Name Type Description [0] bool count the current day and number of stakes remaining concatted with _stakeEndByConsent function _stakeEndByConsent(uint256 stakeId, address tipTo, uint256 count) internal returns (uint256) end a stake with the consent of the underlying staker's settings hedron minting happens as last step before end stake the stake count is today | stake count because if there were 2 variables, the contract ended up too large Parameters Name Type Description stakeId uint256 the stake id to end tipTo address count uint256 Return Values Name Type Description [0] uint256 delta the amount of hex at the end of the stake stakeEndByConsentForManyWithTipTo function stakeEndByConsentForManyWithTipTo(uint256[] stakeIds, address tipTo) external payable returns (uint256, uint256[]) end many stakes at the same time provides an optimized path for all stake ends and assumes that detectable failures should be skipped this method should, generally, only be called when multiple enders are attempting to end stake the same stakes Parameters Name Type Description stakeIds uint256[] stake ids to end tipTo address Return Values Name Type Description [0] uint256 ended a counter [1] uint256[]","title":"StakeEnder"},{"location":"api/StakeEnder/#stakeender","text":"","title":"StakeEnder"},{"location":"api/StakeEnder/#index_right_today","text":"uint256 INDEX_RIGHT_TODAY","title":"INDEX_RIGHT_TODAY"},{"location":"api/StakeEnder/#stakeendbyconsentwithtipto","text":"function stakeEndByConsentWithTipTo(uint256 stakeId, address tipTo) external payable returns (bool) end a stake, given its settings, and tip to a given address","title":"stakeEndByConsentWithTipTo"},{"location":"api/StakeEnder/#parameters","text":"Name Type Description stakeId uint256 the stake id being targeted for ending tipTo address where to send tokens from tips","title":"Parameters"},{"location":"api/StakeEnder/#return-values","text":"Name Type Description [0] bool count the current day and number of stakes remaining concatted with","title":"Return Values"},{"location":"api/StakeEnder/#_stakeendbyconsent","text":"function _stakeEndByConsent(uint256 stakeId, address tipTo, uint256 count) internal returns (uint256) end a stake with the consent of the underlying staker's settings hedron minting happens as last step before end stake the stake count is today | stake count because if there were 2 variables, the contract ended up too large","title":"_stakeEndByConsent"},{"location":"api/StakeEnder/#parameters_1","text":"Name Type Description stakeId uint256 the stake id to end tipTo address count uint256","title":"Parameters"},{"location":"api/StakeEnder/#return-values_1","text":"Name Type Description [0] uint256 delta the amount of hex at the end of the stake","title":"Return Values"},{"location":"api/StakeEnder/#stakeendbyconsentformanywithtipto","text":"function stakeEndByConsentForManyWithTipTo(uint256[] stakeIds, address tipTo) external payable returns (uint256, uint256[]) end many stakes at the same time provides an optimized path for all stake ends and assumes that detectable failures should be skipped this method should, generally, only be called when multiple enders are attempting to end stake the same stakes","title":"stakeEndByConsentForManyWithTipTo"},{"location":"api/StakeEnder/#parameters_2","text":"Name Type Description stakeIds uint256[] stake ids to end tipTo address","title":"Parameters"},{"location":"api/StakeEnder/#return-values_2","text":"Name Type Description [0] uint256 ended a counter [1] uint256[]","title":"Return Values"},{"location":"api/StakeInfo/","text":"StakeInfo stakeIdInfo mapping(uint256 => uint256) stakeIdInfo the owner of a stake indexed by the stake id index + 160(owner) StakeNotOwned error StakeNotOwned(address provided, address expected) this error is thrown when the stake in question is not owned by the expected address StakeNotCustodied error StakeNotCustodied(uint256 stakeId) verifyStakeOwnership function verifyStakeOwnership(address owner, uint256 stakeId) external view verify the ownership of a stake given its id error occurs if owner does not match Parameters Name Type Description owner address the supposed owner of the stake stakeId uint256 the id of the stake in question _verifyStakeOwnership function _verifyStakeOwnership(address owner, uint256 stakeId) internal view verify the ownership of a stake given its id StakeNotOwned error occurs if owner does not match Parameters Name Type Description owner address the supposed owner of the stake stakeId uint256 the id of the stake in question verifyCustodian function verifyCustodian(uint256 stakeId) external view verify that this contract knows the owner of a given stake id and is acting as custodian for said owner StakeNotCustodied error occurs if owner is not known Parameters Name Type Description stakeId uint256 the stake id to verify custodialship over _verifyCustodian function _verifyCustodian(uint256 stakeId) internal view verify that this contract knows the owner of a given stake id and is acting as custodian for said owner StakeNotCustodied error occurs if owner is not known Parameters Name Type Description stakeId uint256 the stake id to verify custodialship over stakeIdToOwner function stakeIdToOwner(uint256 stakeId) external view returns (address owner) get the owner of the stake id - the account that has rights over the stake's settings and ability to end it outright value will be address(0) for unknown Parameters Name Type Description stakeId uint256 the stake id in question Return Values Name Type Description owner address of the stake at the provided id _stakeIdToOwner function _stakeIdToOwner(uint256 stakeId) internal view returns (address owner) access the owner of a given stake id value will be address(0) for unknown Parameters Name Type Description stakeId uint256 the stake id in question Return Values Name Type Description owner address of a given stake id stakeIdToInfo function stakeIdToInfo(uint256 stakeId) external view returns (uint256 index, address owner) get the info of a stake given it's id. The index must match the index of the stake in the hex/hedron contract Parameters Name Type Description stakeId uint256 the stake id to get info for Return Values Name Type Description index uint256 of the stake id in the hex list owner address of the stake _stakeIdToInfo function _stakeIdToInfo(uint256 stakeId) internal view returns (uint256 index, address owner) retrieve the index and owner of a stake id for a non custodied stake, the index is 0 and the owner is address(0) Parameters Name Type Description stakeId uint256 the id of the stake in question Return Values Name Type Description index uint256 the index of the stake in the hex list or the hsim list owner address the owner of the stake stakeIdToIndex function stakeIdToIndex(uint256 stakeId) external view returns (uint256 index) the index of the stake id - useful when indexes are moving around and could be moved by other people Parameters Name Type Description stakeId uint256 the stake id to target Return Values Name Type Description index uint256 of the stake in the targeted list _stakeIdToIndex function _stakeIdToIndex(uint256 stakeId) internal view returns (uint256 index) the index of the stake id - useful when indexes are moving around and could be moved by other people Parameters Name Type Description stakeId uint256 the stake id to target Return Values Name Type Description index uint256 of the stake in the targeted list encodeInfo function encodeInfo(uint256 index, address owner) external pure returns (uint256 info) encode an index and owner pair to track under a single sload Parameters Name Type Description index uint256 index of a stake owner address the owner of a stake Return Values Name Type Description info uint256 the encoded uint256 that can be decoded to the index and owner _encodeInfo function _encodeInfo(uint256 index, address owner) internal pure returns (uint256 info) encode an index and owner pair to track under a single sload Parameters Name Type Description index uint256 index of a stake owner address the owner of a stake Return Values Name Type Description info uint256 the encoded uint256 that can be decoded to the index and owner","title":"StakeInfo"},{"location":"api/StakeInfo/#stakeinfo","text":"","title":"StakeInfo"},{"location":"api/StakeInfo/#stakeidinfo","text":"mapping(uint256 => uint256) stakeIdInfo the owner of a stake indexed by the stake id index + 160(owner)","title":"stakeIdInfo"},{"location":"api/StakeInfo/#stakenotowned","text":"error StakeNotOwned(address provided, address expected) this error is thrown when the stake in question is not owned by the expected address","title":"StakeNotOwned"},{"location":"api/StakeInfo/#stakenotcustodied","text":"error StakeNotCustodied(uint256 stakeId)","title":"StakeNotCustodied"},{"location":"api/StakeInfo/#verifystakeownership","text":"function verifyStakeOwnership(address owner, uint256 stakeId) external view verify the ownership of a stake given its id error occurs if owner does not match","title":"verifyStakeOwnership"},{"location":"api/StakeInfo/#parameters","text":"Name Type Description owner address the supposed owner of the stake stakeId uint256 the id of the stake in question","title":"Parameters"},{"location":"api/StakeInfo/#_verifystakeownership","text":"function _verifyStakeOwnership(address owner, uint256 stakeId) internal view verify the ownership of a stake given its id StakeNotOwned error occurs if owner does not match","title":"_verifyStakeOwnership"},{"location":"api/StakeInfo/#parameters_1","text":"Name Type Description owner address the supposed owner of the stake stakeId uint256 the id of the stake in question","title":"Parameters"},{"location":"api/StakeInfo/#verifycustodian","text":"function verifyCustodian(uint256 stakeId) external view verify that this contract knows the owner of a given stake id and is acting as custodian for said owner StakeNotCustodied error occurs if owner is not known","title":"verifyCustodian"},{"location":"api/StakeInfo/#parameters_2","text":"Name Type Description stakeId uint256 the stake id to verify custodialship over","title":"Parameters"},{"location":"api/StakeInfo/#_verifycustodian","text":"function _verifyCustodian(uint256 stakeId) internal view verify that this contract knows the owner of a given stake id and is acting as custodian for said owner StakeNotCustodied error occurs if owner is not known","title":"_verifyCustodian"},{"location":"api/StakeInfo/#parameters_3","text":"Name Type Description stakeId uint256 the stake id to verify custodialship over","title":"Parameters"},{"location":"api/StakeInfo/#stakeidtoowner","text":"function stakeIdToOwner(uint256 stakeId) external view returns (address owner) get the owner of the stake id - the account that has rights over the stake's settings and ability to end it outright value will be address(0) for unknown","title":"stakeIdToOwner"},{"location":"api/StakeInfo/#parameters_4","text":"Name Type Description stakeId uint256 the stake id in question","title":"Parameters"},{"location":"api/StakeInfo/#return-values","text":"Name Type Description owner address of the stake at the provided id","title":"Return Values"},{"location":"api/StakeInfo/#_stakeidtoowner","text":"function _stakeIdToOwner(uint256 stakeId) internal view returns (address owner) access the owner of a given stake id value will be address(0) for unknown","title":"_stakeIdToOwner"},{"location":"api/StakeInfo/#parameters_5","text":"Name Type Description stakeId uint256 the stake id in question","title":"Parameters"},{"location":"api/StakeInfo/#return-values_1","text":"Name Type Description owner address of a given stake id","title":"Return Values"},{"location":"api/StakeInfo/#stakeidtoinfo","text":"function stakeIdToInfo(uint256 stakeId) external view returns (uint256 index, address owner) get the info of a stake given it's id. The index must match the index of the stake in the hex/hedron contract","title":"stakeIdToInfo"},{"location":"api/StakeInfo/#parameters_6","text":"Name Type Description stakeId uint256 the stake id to get info for","title":"Parameters"},{"location":"api/StakeInfo/#return-values_2","text":"Name Type Description index uint256 of the stake id in the hex list owner address of the stake","title":"Return Values"},{"location":"api/StakeInfo/#_stakeidtoinfo","text":"function _stakeIdToInfo(uint256 stakeId) internal view returns (uint256 index, address owner) retrieve the index and owner of a stake id for a non custodied stake, the index is 0 and the owner is address(0)","title":"_stakeIdToInfo"},{"location":"api/StakeInfo/#parameters_7","text":"Name Type Description stakeId uint256 the id of the stake in question","title":"Parameters"},{"location":"api/StakeInfo/#return-values_3","text":"Name Type Description index uint256 the index of the stake in the hex list or the hsim list owner address the owner of the stake","title":"Return Values"},{"location":"api/StakeInfo/#stakeidtoindex","text":"function stakeIdToIndex(uint256 stakeId) external view returns (uint256 index) the index of the stake id - useful when indexes are moving around and could be moved by other people","title":"stakeIdToIndex"},{"location":"api/StakeInfo/#parameters_8","text":"Name Type Description stakeId uint256 the stake id to target","title":"Parameters"},{"location":"api/StakeInfo/#return-values_4","text":"Name Type Description index uint256 of the stake in the targeted list","title":"Return Values"},{"location":"api/StakeInfo/#_stakeidtoindex","text":"function _stakeIdToIndex(uint256 stakeId) internal view returns (uint256 index) the index of the stake id - useful when indexes are moving around and could be moved by other people","title":"_stakeIdToIndex"},{"location":"api/StakeInfo/#parameters_9","text":"Name Type Description stakeId uint256 the stake id to target","title":"Parameters"},{"location":"api/StakeInfo/#return-values_5","text":"Name Type Description index uint256 of the stake in the targeted list","title":"Return Values"},{"location":"api/StakeInfo/#encodeinfo","text":"function encodeInfo(uint256 index, address owner) external pure returns (uint256 info) encode an index and owner pair to track under a single sload","title":"encodeInfo"},{"location":"api/StakeInfo/#parameters_10","text":"Name Type Description index uint256 index of a stake owner address the owner of a stake","title":"Parameters"},{"location":"api/StakeInfo/#return-values_6","text":"Name Type Description info uint256 the encoded uint256 that can be decoded to the index and owner","title":"Return Values"},{"location":"api/StakeInfo/#_encodeinfo","text":"function _encodeInfo(uint256 index, address owner) internal pure returns (uint256 info) encode an index and owner pair to track under a single sload","title":"_encodeInfo"},{"location":"api/StakeInfo/#parameters_11","text":"Name Type Description index uint256 index of a stake owner address the owner of a stake","title":"Parameters"},{"location":"api/StakeInfo/#return-values_7","text":"Name Type Description info uint256 the encoded uint256 that can be decoded to the index and owner","title":"Return Values"},{"location":"api/StakeManager/","text":"StakeManager","title":"StakeManager"},{"location":"api/StakeManager/#stakemanager","text":"","title":"StakeManager"},{"location":"api/StakeStarter/","text":"StakeStarter stakeStartFromBalanceFor function stakeStartFromBalanceFor(address to, uint256 amount, uint256 newStakedDays, uint256 settings) external payable returns (uint256 stakeId) stake a given number of tokens for a given number of days Parameters Name Type Description to address the address that will own the staker amount uint256 the number of tokens to stake newStakedDays uint256 the number of days to stake for settings uint256 stakeStartFromWithdrawableFor function stakeStartFromWithdrawableFor(address to, uint256 amount, uint256 newStakedDays, uint256 settings) external payable returns (uint256 stakeId) start a numbeer of stakes for an address from the withdrawable Parameters Name Type Description to address the account to start a stake for amount uint256 the number of tokens to start a stake for newStakedDays uint256 the number of days to stake for settings uint256 stakeStartFromUnattributedFor function stakeStartFromUnattributedFor(address to, uint256 amount, uint256 newStakedDays, uint256 settings) external payable returns (uint256 stakeId) stake a number of tokens for a given number of days, pulling from the unattributed tokens in this contract Parameters Name Type Description to address the owner of the stake amount uint256 the amount of tokens to stake newStakedDays uint256 the number of days to stake settings uint256","title":"StakeStarter"},{"location":"api/StakeStarter/#stakestarter","text":"","title":"StakeStarter"},{"location":"api/StakeStarter/#stakestartfrombalancefor","text":"function stakeStartFromBalanceFor(address to, uint256 amount, uint256 newStakedDays, uint256 settings) external payable returns (uint256 stakeId) stake a given number of tokens for a given number of days","title":"stakeStartFromBalanceFor"},{"location":"api/StakeStarter/#parameters","text":"Name Type Description to address the address that will own the staker amount uint256 the number of tokens to stake newStakedDays uint256 the number of days to stake for settings uint256","title":"Parameters"},{"location":"api/StakeStarter/#stakestartfromwithdrawablefor","text":"function stakeStartFromWithdrawableFor(address to, uint256 amount, uint256 newStakedDays, uint256 settings) external payable returns (uint256 stakeId) start a numbeer of stakes for an address from the withdrawable","title":"stakeStartFromWithdrawableFor"},{"location":"api/StakeStarter/#parameters_1","text":"Name Type Description to address the account to start a stake for amount uint256 the number of tokens to start a stake for newStakedDays uint256 the number of days to stake for settings uint256","title":"Parameters"},{"location":"api/StakeStarter/#stakestartfromunattributedfor","text":"function stakeStartFromUnattributedFor(address to, uint256 amount, uint256 newStakedDays, uint256 settings) external payable returns (uint256 stakeId) stake a number of tokens for a given number of days, pulling from the unattributed tokens in this contract","title":"stakeStartFromUnattributedFor"},{"location":"api/StakeStarter/#parameters_2","text":"Name Type Description to address the owner of the stake amount uint256 the amount of tokens to stake newStakedDays uint256 the number of days to stake settings uint256","title":"Parameters"},{"location":"api/Tipper/","text":"Tipper INDEX_EXTERNAL_TIP_CURRENCY_ONLY uint256 INDEX_EXTERNAL_TIP_CURRENCY_ONLY INDEX_EXTERNAL_TIP_LIMIT uint256 INDEX_EXTERNAL_TIP_LIMIT constructor constructor() internal tipStakeIdToStaker mapping(uint256 => address) tipStakeIdToStaker this mapping is needed for the case where a tip is added to a stake but the staker ends the stake on a lower level which never checks for tips this mapping slightly increases the cost of initializing tips as well as transferring them but that is ok, because we generally do not want people to be trading stakes at this level of anyone wants to be swapping ownership over stakes then they can create an erc721 and trade at a higher level also end stakers get a larger refund due to more information being zero'd out it is set to internal because, generally, the stake id should be going to the lower level stakeIdInfo mapping and individuals who do not wish to tip should not be charged 2k gas for checking if this mapping exists stakeIdTips mapping(uint256 => uint256[]) stakeIdTips AddTip event AddTip(uint256 stakeId, address token, uint256 index, uint256 settings) RemoveTip event RemoveTip(uint256 stakeId, address token, uint256 index, uint256 settings) Tip event Tip(uint256 stakeId, address token, address to, uint256 amount) tip an address a defined amount and token Parameters Name Type Description stakeId uint256 the stake id being targeted token address the token being accounted to address the address to attribute rewards to amount uint256 the amount of the token stakeIdTipSize function stakeIdTipSize(uint256 stakeId) external view returns (uint256) check the count of a list of tips provided by the staker Parameters Name Type Description stakeId uint256 the stake id to check the list of tips Return Values Name Type Description [0] uint256 size of tip list backing a given stake id _stakeIdTipSize function _stakeIdTipSize(uint256 stakeId) internal view returns (uint256) check the count of a list of tips provided by the staker Parameters Name Type Description stakeId uint256 the stake id to check the list of tips computeTip function computeTip(uint256 tip) external view returns (uint256 limit, uint256 consumed) compute the limit (input from staker) and the final tip (attributable to ender) using the base fee and limit as v1 and v2 respectively Parameters Name Type Description tip uint256 the encoded tip, holding the limit and a linear definition Return Values Name Type Description limit uint256 the limit parsed from the tip value consumed uint256 the number of tokens consumed by the tip _computeTip function _computeTip(uint256 tip) internal view returns (uint256 limit, uint256 consumed) _executeTipList function _executeTipList(uint256 stakeId, address staker, uint256 nextStakeId, address tipTo) internal returns (uint256 nextStakeTipsLength) execute a list of tips and leave them in the unattributed space Parameters Name Type Description stakeId uint256 the stake id whose tips should be executed staker address the staker that owns the stake id nextStakeId uint256 the next stake id if tips are to be copied / rolled over tipTo address encodeTipSettings function encodeTipSettings(bool reusable, uint256 currencyIndex, uint256 amount, uint256 encodedLinear) external pure returns (uint256) encodes a series of data in 32+96+64+64 to fit into 256 bits to define how a tip should be executed Parameters Name Type Description reusable bool currencyIndex uint256 the index of the currency on the list amount uint256 the number of tokens to delineate as tips encodedLinear uint256 the method+xyb function to use _encodeTipSettings function _encodeTipSettings(bool reusable, uint256 currencyIndex, uint256 amount, uint256 encodedLinear) internal pure returns (uint256) encodes tip settings into a uint256 Parameters Name Type Description reusable bool the tip can be reused if there is amount left over currencyIndex uint256 the index of the currency on the list amount uint256 the number of tokens deposited into the contract encodedLinear uint256 an (x/y)+b equation inside of uint72 depositAndAddTipToStake function depositAndAddTipToStake(bool reusable, address token, uint256 stakeId, uint256 amount, uint256 encodedLinear) external payable virtual returns (uint256, uint256) create a tip and back it with a token, to be executed by the stake ender Parameters Name Type Description reusable bool the tip can be reused if value is still present after it has been executed token address the token to fund the tip stakeId uint256 the stake id that the tip belongs to amount uint256 the number of tokens to back the tip with use zero to move all withdrawableBalanceOf value encodedLinear uint256 the (x/y)+b equation to define how much of the tip to spend Return Values Name Type Description [0] uint256 index of the tip in the list [1] uint256 tipAmount the final backing value of the tip removeAllTips function removeAllTips(uint256 stakeId) external remove all tips from a stake id and moves them to the withdrawableBalanceOf the owner of the stake if the sender does not own the stake id, the call will fail Parameters Name Type Description stakeId uint256 the stake id to remove all tips from _removeAllTips function _removeAllTips(uint256 stakeId, uint256 settings) internal remove all tips from a stake id and moves them to the withdrawableBalanceOf the owner of the stake Parameters Name Type Description stakeId uint256 the stake id to remove all tips from settings uint256 the settings of the stake used for determining whether or not to send funds back to staker removeTipsFromStake function removeTipsFromStake(uint256 stakeId, uint256[] indexes) external payable remove a list of tip indexes from a given stake notice that the list of stakes will be mutated as each tip is removed so you will have to calculate off chain where tips will move to or provide a list such as [0, 0, 0] or decrementing [5,4,3,2,1,0] that will not be affected by the list mutating Parameters Name Type Description stakeId uint256 the stake id to remove tips from indexes uint256[] the list of indexes of tips to be removed from the list _removeTipsFromStake function _removeTipsFromStake(uint256 stakeId, uint256 settings, uint256[] indexes) internal addTipToStake function addTipToStake(bool reusable, address token, uint256 stakeId, uint256 amount, uint256 encodedLinear) external payable virtual returns (uint256, uint256) create and back a tip with a given number of tokens Parameters Name Type Description reusable bool the tip is reusable token address the token to use in the tip stakeId uint256 the stake id to attribute the tip to amount uint256 the number of tokens to tip encodedLinear uint256 the (x/y)+b equation to use for determining the magnitude of the tip Return Values Name Type Description [0] uint256 the index of the tip in the list [1] uint256 the final tip amount _verifyTipAmountAllowed function _verifyTipAmountAllowed(uint256 stakeId, uint256 amount) internal view returns (address recipient) verify that the inputs of the tip are allowed and will not conflict with downstream requirements Parameters Name Type Description stakeId uint256 the stake id to verify amount uint256 the amount to verify. notice that zero cannot be used unless the sender owns the stake. this is to prevent addresses from taking other accounts funding Return Values Name Type Description recipient address who will be the effective owner of the tip _checkStakeCustodian function _checkStakeCustodian(uint256 stakeId) internal view virtual check that this contract is custodian of the given stake id Parameters Name Type Description stakeId uint256 the stake id to check that this address is the custodian _addTipToStake function _addTipToStake(bool reusable, address token, address account, uint256 stakeId, uint256 amount, uint256 encodedLinear) internal returns (uint256 index, uint256 tipAmount) create a tip and back it with given tokens Parameters Name Type Description reusable bool the tip should be reused if it is not consumed during execution token address the token that is backing the tips value account address the account that is providing the tokens stakeId uint256 the stake id to point the tip to amount uint256 the number of tokens to back the tip encodedLinear uint256 the (x/y)+b equation Return Values Name Type Description index uint256 the index of the tip in the tips list tipAmount uint256 the amount of tokens added to the tip receive receive() external payable","title":"Tipper"},{"location":"api/Tipper/#tipper","text":"","title":"Tipper"},{"location":"api/Tipper/#index_external_tip_currency_only","text":"uint256 INDEX_EXTERNAL_TIP_CURRENCY_ONLY","title":"INDEX_EXTERNAL_TIP_CURRENCY_ONLY"},{"location":"api/Tipper/#index_external_tip_limit","text":"uint256 INDEX_EXTERNAL_TIP_LIMIT","title":"INDEX_EXTERNAL_TIP_LIMIT"},{"location":"api/Tipper/#constructor","text":"constructor() internal","title":"constructor"},{"location":"api/Tipper/#tipstakeidtostaker","text":"mapping(uint256 => address) tipStakeIdToStaker this mapping is needed for the case where a tip is added to a stake but the staker ends the stake on a lower level which never checks for tips this mapping slightly increases the cost of initializing tips as well as transferring them but that is ok, because we generally do not want people to be trading stakes at this level of anyone wants to be swapping ownership over stakes then they can create an erc721 and trade at a higher level also end stakers get a larger refund due to more information being zero'd out it is set to internal because, generally, the stake id should be going to the lower level stakeIdInfo mapping and individuals who do not wish to tip should not be charged 2k gas for checking if this mapping exists","title":"tipStakeIdToStaker"},{"location":"api/Tipper/#stakeidtips","text":"mapping(uint256 => uint256[]) stakeIdTips","title":"stakeIdTips"},{"location":"api/Tipper/#addtip","text":"event AddTip(uint256 stakeId, address token, uint256 index, uint256 settings)","title":"AddTip"},{"location":"api/Tipper/#removetip","text":"event RemoveTip(uint256 stakeId, address token, uint256 index, uint256 settings)","title":"RemoveTip"},{"location":"api/Tipper/#tip","text":"event Tip(uint256 stakeId, address token, address to, uint256 amount) tip an address a defined amount and token","title":"Tip"},{"location":"api/Tipper/#parameters","text":"Name Type Description stakeId uint256 the stake id being targeted token address the token being accounted to address the address to attribute rewards to amount uint256 the amount of the token","title":"Parameters"},{"location":"api/Tipper/#stakeidtipsize","text":"function stakeIdTipSize(uint256 stakeId) external view returns (uint256) check the count of a list of tips provided by the staker","title":"stakeIdTipSize"},{"location":"api/Tipper/#parameters_1","text":"Name Type Description stakeId uint256 the stake id to check the list of tips","title":"Parameters"},{"location":"api/Tipper/#return-values","text":"Name Type Description [0] uint256 size of tip list backing a given stake id","title":"Return Values"},{"location":"api/Tipper/#_stakeidtipsize","text":"function _stakeIdTipSize(uint256 stakeId) internal view returns (uint256) check the count of a list of tips provided by the staker","title":"_stakeIdTipSize"},{"location":"api/Tipper/#parameters_2","text":"Name Type Description stakeId uint256 the stake id to check the list of tips","title":"Parameters"},{"location":"api/Tipper/#computetip","text":"function computeTip(uint256 tip) external view returns (uint256 limit, uint256 consumed) compute the limit (input from staker) and the final tip (attributable to ender) using the base fee and limit as v1 and v2 respectively","title":"computeTip"},{"location":"api/Tipper/#parameters_3","text":"Name Type Description tip uint256 the encoded tip, holding the limit and a linear definition","title":"Parameters"},{"location":"api/Tipper/#return-values_1","text":"Name Type Description limit uint256 the limit parsed from the tip value consumed uint256 the number of tokens consumed by the tip","title":"Return Values"},{"location":"api/Tipper/#_computetip","text":"function _computeTip(uint256 tip) internal view returns (uint256 limit, uint256 consumed)","title":"_computeTip"},{"location":"api/Tipper/#_executetiplist","text":"function _executeTipList(uint256 stakeId, address staker, uint256 nextStakeId, address tipTo) internal returns (uint256 nextStakeTipsLength) execute a list of tips and leave them in the unattributed space","title":"_executeTipList"},{"location":"api/Tipper/#parameters_4","text":"Name Type Description stakeId uint256 the stake id whose tips should be executed staker address the staker that owns the stake id nextStakeId uint256 the next stake id if tips are to be copied / rolled over tipTo address","title":"Parameters"},{"location":"api/Tipper/#encodetipsettings","text":"function encodeTipSettings(bool reusable, uint256 currencyIndex, uint256 amount, uint256 encodedLinear) external pure returns (uint256) encodes a series of data in 32+96+64+64 to fit into 256 bits to define how a tip should be executed","title":"encodeTipSettings"},{"location":"api/Tipper/#parameters_5","text":"Name Type Description reusable bool currencyIndex uint256 the index of the currency on the list amount uint256 the number of tokens to delineate as tips encodedLinear uint256 the method+xyb function to use","title":"Parameters"},{"location":"api/Tipper/#_encodetipsettings","text":"function _encodeTipSettings(bool reusable, uint256 currencyIndex, uint256 amount, uint256 encodedLinear) internal pure returns (uint256) encodes tip settings into a uint256","title":"_encodeTipSettings"},{"location":"api/Tipper/#parameters_6","text":"Name Type Description reusable bool the tip can be reused if there is amount left over currencyIndex uint256 the index of the currency on the list amount uint256 the number of tokens deposited into the contract encodedLinear uint256 an (x/y)+b equation inside of uint72","title":"Parameters"},{"location":"api/Tipper/#depositandaddtiptostake","text":"function depositAndAddTipToStake(bool reusable, address token, uint256 stakeId, uint256 amount, uint256 encodedLinear) external payable virtual returns (uint256, uint256) create a tip and back it with a token, to be executed by the stake ender","title":"depositAndAddTipToStake"},{"location":"api/Tipper/#parameters_7","text":"Name Type Description reusable bool the tip can be reused if value is still present after it has been executed token address the token to fund the tip stakeId uint256 the stake id that the tip belongs to amount uint256 the number of tokens to back the tip with use zero to move all withdrawableBalanceOf value encodedLinear uint256 the (x/y)+b equation to define how much of the tip to spend","title":"Parameters"},{"location":"api/Tipper/#return-values_2","text":"Name Type Description [0] uint256 index of the tip in the list [1] uint256 tipAmount the final backing value of the tip","title":"Return Values"},{"location":"api/Tipper/#removealltips","text":"function removeAllTips(uint256 stakeId) external remove all tips from a stake id and moves them to the withdrawableBalanceOf the owner of the stake if the sender does not own the stake id, the call will fail","title":"removeAllTips"},{"location":"api/Tipper/#parameters_8","text":"Name Type Description stakeId uint256 the stake id to remove all tips from","title":"Parameters"},{"location":"api/Tipper/#_removealltips","text":"function _removeAllTips(uint256 stakeId, uint256 settings) internal remove all tips from a stake id and moves them to the withdrawableBalanceOf the owner of the stake","title":"_removeAllTips"},{"location":"api/Tipper/#parameters_9","text":"Name Type Description stakeId uint256 the stake id to remove all tips from settings uint256 the settings of the stake used for determining whether or not to send funds back to staker","title":"Parameters"},{"location":"api/Tipper/#removetipsfromstake","text":"function removeTipsFromStake(uint256 stakeId, uint256[] indexes) external payable remove a list of tip indexes from a given stake notice that the list of stakes will be mutated as each tip is removed so you will have to calculate off chain where tips will move to or provide a list such as [0, 0, 0] or decrementing [5,4,3,2,1,0] that will not be affected by the list mutating","title":"removeTipsFromStake"},{"location":"api/Tipper/#parameters_10","text":"Name Type Description stakeId uint256 the stake id to remove tips from indexes uint256[] the list of indexes of tips to be removed from the list","title":"Parameters"},{"location":"api/Tipper/#_removetipsfromstake","text":"function _removeTipsFromStake(uint256 stakeId, uint256 settings, uint256[] indexes) internal","title":"_removeTipsFromStake"},{"location":"api/Tipper/#addtiptostake","text":"function addTipToStake(bool reusable, address token, uint256 stakeId, uint256 amount, uint256 encodedLinear) external payable virtual returns (uint256, uint256) create and back a tip with a given number of tokens","title":"addTipToStake"},{"location":"api/Tipper/#parameters_11","text":"Name Type Description reusable bool the tip is reusable token address the token to use in the tip stakeId uint256 the stake id to attribute the tip to amount uint256 the number of tokens to tip encodedLinear uint256 the (x/y)+b equation to use for determining the magnitude of the tip","title":"Parameters"},{"location":"api/Tipper/#return-values_3","text":"Name Type Description [0] uint256 the index of the tip in the list [1] uint256 the final tip amount","title":"Return Values"},{"location":"api/Tipper/#_verifytipamountallowed","text":"function _verifyTipAmountAllowed(uint256 stakeId, uint256 amount) internal view returns (address recipient) verify that the inputs of the tip are allowed and will not conflict with downstream requirements","title":"_verifyTipAmountAllowed"},{"location":"api/Tipper/#parameters_12","text":"Name Type Description stakeId uint256 the stake id to verify amount uint256 the amount to verify. notice that zero cannot be used unless the sender owns the stake. this is to prevent addresses from taking other accounts funding","title":"Parameters"},{"location":"api/Tipper/#return-values_4","text":"Name Type Description recipient address who will be the effective owner of the tip","title":"Return Values"},{"location":"api/Tipper/#_checkstakecustodian","text":"function _checkStakeCustodian(uint256 stakeId) internal view virtual check that this contract is custodian of the given stake id","title":"_checkStakeCustodian"},{"location":"api/Tipper/#parameters_13","text":"Name Type Description stakeId uint256 the stake id to check that this address is the custodian","title":"Parameters"},{"location":"api/Tipper/#_addtiptostake","text":"function _addTipToStake(bool reusable, address token, address account, uint256 stakeId, uint256 amount, uint256 encodedLinear) internal returns (uint256 index, uint256 tipAmount) create a tip and back it with given tokens","title":"_addTipToStake"},{"location":"api/Tipper/#parameters_14","text":"Name Type Description reusable bool the tip should be reused if it is not consumed during execution token address the token that is backing the tips value account address the account that is providing the tokens stakeId uint256 the stake id to point the tip to amount uint256 the number of tokens to back the tip encodedLinear uint256 the (x/y)+b equation","title":"Parameters"},{"location":"api/Tipper/#return-values_5","text":"Name Type Description index uint256 the index of the tip in the tips list tipAmount uint256 the amount of tokens added to the tip","title":"Return Values"},{"location":"api/Tipper/#receive","text":"receive() external payable","title":"receive"},{"location":"api/TransferableStakeManager/","text":"TransferableStakeManager TransferStake event TransferStake(address from, address to, address owner, uint256 stakeId) a stake's ownership has been transferred from one address to another if 2 contracts are involved, they can use the owner param to internal accounting ownership Parameters Name Type Description from address the address who owns the stake according to stake manager contracts to address the address where the stake is being transferred owner address the owner of the stake if there is separate accounting occuring in the \"from\" address stakeId uint256 the stake id being transferred InvalidStakeReceiver error InvalidStakeReceiver(address to) removeTransferrability function removeTransferrability(uint256 stakeId) external payable returns (uint256 settings) removes transfer abilities from a stake Parameters Name Type Description stakeId uint256 the stake that the sender owns and wishes to remove transfer abilities from removeTransferrabilityFromSettings function removeTransferrabilityFromSettings(uint256 settings) external pure returns (uint256) rewrite encoded settings to remove the transferable flag and leave all other settings in tact Parameters Name Type Description settings uint256 encoded settings to rewrite without a transferable flag _removeTransferrabilityFromSettings function _removeTransferrabilityFromSettings(uint256 settings) internal pure returns (uint256) rewrite encoded settings to remove the transferable flag and leave all other settings in tact Parameters Name Type Description settings uint256 encoded settings to rewrite without a transferable flag canTransfer function canTransfer(uint256 stakeId) external view returns (bool) check if a given stake under a stake id can be transferred Parameters Name Type Description stakeId uint256 the stake id to check transferrability settings _canTransfer function _canTransfer(uint256 stakeId) internal view returns (bool) check if a given stake under a stake id can be transferred Parameters Name Type Description stakeId uint256 the stake id to check transferrability settings stakeTransfer function stakeTransfer(address to, address owner, uint256 stakeId) external payable transfer a stake from one owner to another this method is only payable to reduce gas costs. Any value sent to this method will be unattributed Parameters Name Type Description to address the account to receive the stake owner address the owner address if there is internal accounting of stakes via contract stakeId uint256 the stake id to transfer","title":"TransferableStakeManager"},{"location":"api/TransferableStakeManager/#transferablestakemanager","text":"","title":"TransferableStakeManager"},{"location":"api/TransferableStakeManager/#transferstake","text":"event TransferStake(address from, address to, address owner, uint256 stakeId) a stake's ownership has been transferred from one address to another if 2 contracts are involved, they can use the owner param to internal accounting ownership","title":"TransferStake"},{"location":"api/TransferableStakeManager/#parameters","text":"Name Type Description from address the address who owns the stake according to stake manager contracts to address the address where the stake is being transferred owner address the owner of the stake if there is separate accounting occuring in the \"from\" address stakeId uint256 the stake id being transferred","title":"Parameters"},{"location":"api/TransferableStakeManager/#invalidstakereceiver","text":"error InvalidStakeReceiver(address to)","title":"InvalidStakeReceiver"},{"location":"api/TransferableStakeManager/#removetransferrability","text":"function removeTransferrability(uint256 stakeId) external payable returns (uint256 settings) removes transfer abilities from a stake","title":"removeTransferrability"},{"location":"api/TransferableStakeManager/#parameters_1","text":"Name Type Description stakeId uint256 the stake that the sender owns and wishes to remove transfer abilities from","title":"Parameters"},{"location":"api/TransferableStakeManager/#removetransferrabilityfromsettings","text":"function removeTransferrabilityFromSettings(uint256 settings) external pure returns (uint256) rewrite encoded settings to remove the transferable flag and leave all other settings in tact","title":"removeTransferrabilityFromSettings"},{"location":"api/TransferableStakeManager/#parameters_2","text":"Name Type Description settings uint256 encoded settings to rewrite without a transferable flag","title":"Parameters"},{"location":"api/TransferableStakeManager/#_removetransferrabilityfromsettings","text":"function _removeTransferrabilityFromSettings(uint256 settings) internal pure returns (uint256) rewrite encoded settings to remove the transferable flag and leave all other settings in tact","title":"_removeTransferrabilityFromSettings"},{"location":"api/TransferableStakeManager/#parameters_3","text":"Name Type Description settings uint256 encoded settings to rewrite without a transferable flag","title":"Parameters"},{"location":"api/TransferableStakeManager/#cantransfer","text":"function canTransfer(uint256 stakeId) external view returns (bool) check if a given stake under a stake id can be transferred","title":"canTransfer"},{"location":"api/TransferableStakeManager/#parameters_4","text":"Name Type Description stakeId uint256 the stake id to check transferrability settings","title":"Parameters"},{"location":"api/TransferableStakeManager/#_cantransfer","text":"function _canTransfer(uint256 stakeId) internal view returns (bool) check if a given stake under a stake id can be transferred","title":"_canTransfer"},{"location":"api/TransferableStakeManager/#parameters_5","text":"Name Type Description stakeId uint256 the stake id to check transferrability settings","title":"Parameters"},{"location":"api/TransferableStakeManager/#staketransfer","text":"function stakeTransfer(address to, address owner, uint256 stakeId) external payable transfer a stake from one owner to another this method is only payable to reduce gas costs. Any value sent to this method will be unattributed","title":"stakeTransfer"},{"location":"api/TransferableStakeManager/#parameters_6","text":"Name Type Description to address the account to receive the stake owner address the owner address if there is internal accounting of stakes via contract stakeId uint256 the stake id to transfer","title":"Parameters"},{"location":"api/UnderlyingStakeManager/","text":"UnderlyingStakeManager _stakeStartFor function _stakeStartFor(address owner, uint256 amount, uint256 newStakedDays, uint256 index) internal virtual returns (uint256 stakeId) start a stake for the staker given the amount and number of days Parameters Name Type Description owner address the underlying owner of the stake amount uint256 the amount to add to the stake newStakedDays uint256 the number of days that the stake should run index uint256 where in the list the stake will be placed. this is a param because it can be cached for internal loops _stakeEnd function _stakeEnd(uint256 stakeIndex, uint256 stakeId, uint256 stakeCountAfter) internal virtual returns (uint256 delta) ends a stake for someone else Parameters Name Type Description stakeIndex uint256 the stake index on the underlying contract to end stakeId uint256 the stake id on the underlying contract to end stakeCountAfter uint256 the stake count after the stake is ended (current length - 1) Return Values Name Type Description delta uint256 the number of tokens that have been received from ending the stake stakeStart function stakeStart(uint256 amount, uint256 newStakedDays) external virtual starts a stake from the provided amount this method interface matches the original underlying token contract Parameters Name Type Description amount uint256 amount of tokens to stake newStakedDays uint256 the number of days for this new stake stakeEnd function stakeEnd(uint256 stakeIndex, uint40 stakeId) external virtual end your own stake which is custodied by the stake manager. skips tip computing this is not payable to match the underlying contract this moves funds back to the sender to make behavior match underlying token this method only checks that the sender owns the stake it does not care if it is managed in a created contract and externally endable by this contract (1) or requires that the staker send start and end methods (0) Parameters Name Type Description stakeIndex uint256 the index on the underlying contract to end stake stakeId uint40 the stake id from the underlying contract to end stake _stakeEndByIndexAndId function _stakeEndByIndexAndId(uint256 stakeIndex, uint256 stakeId) internal virtual returns (uint256 amount) end a stake given its index and id Parameters Name Type Description stakeIndex uint256 the index of the stake to end stakeId uint256 the stake id to end stakeEndById function stakeEndById(uint256 stakeId) external virtual returns (uint256 amount) end your own stake which is custodied by the stake manager. skips tip computing this is not payable to match the underlying contract this moves funds back to the sender to make behavior match underlying token this method only checks that the sender owns the stake it does not care if it is managed in a created contract and externally endable by this contract (1) or requires that the staker send start and end methods (0) Parameters Name Type Description stakeId uint256 the stake id from the underlying contract to end stake _getStakeInfo function _getStakeInfo(uint256 stakeId) internal view virtual returns (bool valid, address staker, uint256 stakeIndex, struct IUnderlyingStakeable.StakeStore stake) _stakeRestartById function _stakeRestartById(uint256 stakeId) internal returns (uint256 amount, uint256 newStakeId) given ownership over a stake, end the stake and restart all of the proceeds Parameters Name Type Description stakeId uint256 the stake id to restart Return Values Name Type Description amount uint256 the amount ended and re-staked newStakeId uint256 the newly recreated stake id stakeRestartById function stakeRestartById(uint256 stakeId) external payable returns (uint256 amount, uint256 newStakeId) given ownership over a stake, stop and restart a stake with all proceeds Parameters Name Type Description stakeId uint256 the stake id to restart Return Values Name Type Description amount uint256 the number of tokens that were ended and added to new stake newStakeId uint256 the newly created stake id stakeRestartManyById function stakeRestartManyById(uint256[] stakeIds) external returns (uint256, uint256[]) given ownership over a list of ids of stakes, restart a list of stakes Parameters Name Type Description stakeIds uint256[] the list of stake ids to iterate over and restart","title":"UnderlyingStakeManager"},{"location":"api/UnderlyingStakeManager/#underlyingstakemanager","text":"","title":"UnderlyingStakeManager"},{"location":"api/UnderlyingStakeManager/#_stakestartfor","text":"function _stakeStartFor(address owner, uint256 amount, uint256 newStakedDays, uint256 index) internal virtual returns (uint256 stakeId) start a stake for the staker given the amount and number of days","title":"_stakeStartFor"},{"location":"api/UnderlyingStakeManager/#parameters","text":"Name Type Description owner address the underlying owner of the stake amount uint256 the amount to add to the stake newStakedDays uint256 the number of days that the stake should run index uint256 where in the list the stake will be placed. this is a param because it can be cached for internal loops","title":"Parameters"},{"location":"api/UnderlyingStakeManager/#_stakeend","text":"function _stakeEnd(uint256 stakeIndex, uint256 stakeId, uint256 stakeCountAfter) internal virtual returns (uint256 delta) ends a stake for someone else","title":"_stakeEnd"},{"location":"api/UnderlyingStakeManager/#parameters_1","text":"Name Type Description stakeIndex uint256 the stake index on the underlying contract to end stakeId uint256 the stake id on the underlying contract to end stakeCountAfter uint256 the stake count after the stake is ended (current length - 1)","title":"Parameters"},{"location":"api/UnderlyingStakeManager/#return-values","text":"Name Type Description delta uint256 the number of tokens that have been received from ending the stake","title":"Return Values"},{"location":"api/UnderlyingStakeManager/#stakestart","text":"function stakeStart(uint256 amount, uint256 newStakedDays) external virtual starts a stake from the provided amount this method interface matches the original underlying token contract","title":"stakeStart"},{"location":"api/UnderlyingStakeManager/#parameters_2","text":"Name Type Description amount uint256 amount of tokens to stake newStakedDays uint256 the number of days for this new stake","title":"Parameters"},{"location":"api/UnderlyingStakeManager/#stakeend","text":"function stakeEnd(uint256 stakeIndex, uint40 stakeId) external virtual end your own stake which is custodied by the stake manager. skips tip computing this is not payable to match the underlying contract this moves funds back to the sender to make behavior match underlying token this method only checks that the sender owns the stake it does not care if it is managed in a created contract and externally endable by this contract (1) or requires that the staker send start and end methods (0)","title":"stakeEnd"},{"location":"api/UnderlyingStakeManager/#parameters_3","text":"Name Type Description stakeIndex uint256 the index on the underlying contract to end stake stakeId uint40 the stake id from the underlying contract to end stake","title":"Parameters"},{"location":"api/UnderlyingStakeManager/#_stakeendbyindexandid","text":"function _stakeEndByIndexAndId(uint256 stakeIndex, uint256 stakeId) internal virtual returns (uint256 amount) end a stake given its index and id","title":"_stakeEndByIndexAndId"},{"location":"api/UnderlyingStakeManager/#parameters_4","text":"Name Type Description stakeIndex uint256 the index of the stake to end stakeId uint256 the stake id to end","title":"Parameters"},{"location":"api/UnderlyingStakeManager/#stakeendbyid","text":"function stakeEndById(uint256 stakeId) external virtual returns (uint256 amount) end your own stake which is custodied by the stake manager. skips tip computing this is not payable to match the underlying contract this moves funds back to the sender to make behavior match underlying token this method only checks that the sender owns the stake it does not care if it is managed in a created contract and externally endable by this contract (1) or requires that the staker send start and end methods (0)","title":"stakeEndById"},{"location":"api/UnderlyingStakeManager/#parameters_5","text":"Name Type Description stakeId uint256 the stake id from the underlying contract to end stake","title":"Parameters"},{"location":"api/UnderlyingStakeManager/#_getstakeinfo","text":"function _getStakeInfo(uint256 stakeId) internal view virtual returns (bool valid, address staker, uint256 stakeIndex, struct IUnderlyingStakeable.StakeStore stake)","title":"_getStakeInfo"},{"location":"api/UnderlyingStakeManager/#_stakerestartbyid","text":"function _stakeRestartById(uint256 stakeId) internal returns (uint256 amount, uint256 newStakeId) given ownership over a stake, end the stake and restart all of the proceeds","title":"_stakeRestartById"},{"location":"api/UnderlyingStakeManager/#parameters_6","text":"Name Type Description stakeId uint256 the stake id to restart","title":"Parameters"},{"location":"api/UnderlyingStakeManager/#return-values_1","text":"Name Type Description amount uint256 the amount ended and re-staked newStakeId uint256 the newly recreated stake id","title":"Return Values"},{"location":"api/UnderlyingStakeManager/#stakerestartbyid","text":"function stakeRestartById(uint256 stakeId) external payable returns (uint256 amount, uint256 newStakeId) given ownership over a stake, stop and restart a stake with all proceeds","title":"stakeRestartById"},{"location":"api/UnderlyingStakeManager/#parameters_7","text":"Name Type Description stakeId uint256 the stake id to restart","title":"Parameters"},{"location":"api/UnderlyingStakeManager/#return-values_2","text":"Name Type Description amount uint256 the number of tokens that were ended and added to new stake newStakeId uint256 the newly created stake id","title":"Return Values"},{"location":"api/UnderlyingStakeManager/#stakerestartmanybyid","text":"function stakeRestartManyById(uint256[] stakeIds) external returns (uint256, uint256[]) given ownership over a list of ids of stakes, restart a list of stakes","title":"stakeRestartManyById"},{"location":"api/UnderlyingStakeManager/#parameters_8","text":"Name Type Description stakeIds uint256[] the list of stake ids to iterate over and restart","title":"Parameters"},{"location":"api/UnderlyingStakeable/","text":"UnderlyingStakeable _getStake function _getStake(address custodian, uint256 index) internal view virtual returns (struct IUnderlyingStakeable.StakeStore) gets the stake store at the provided index Parameters Name Type Description custodian address the custodian (usually this) whose list to check index uint256 the index of the stake to get Return Values Name Type Description [0] struct IUnderlyingStakeable.StakeStore the stake on the list at the provided index stakeCount function stakeCount(address staker) external view returns (uint256 count) the count of stakes for a given custodian / staker Parameters Name Type Description staker address the custodian in question Return Values Name Type Description count uint256 of the stakes under a given custodian / staker _stakeCount function _stakeCount(address staker) internal view returns (uint256 count) the count of stakes for a given custodian / staker Parameters Name Type Description staker address the custodian in question Return Values Name Type Description count uint256 of the stakes under a given custodian / staker _getStakeCount function _getStakeCount(address staker) internal view virtual returns (uint256 count) balanceOf function balanceOf(address owner) external view returns (uint256 amount) retrieve the balance of a given owner Parameters Name Type Description owner address the owner of the tokens Return Values Name Type Description amount uint256 a balance amount _balanceOf function _balanceOf(address owner) internal view returns (uint256 amount) retrieve the balance of a given owner Parameters Name Type Description owner address the owner of the tokens Return Values Name Type Description amount uint256 a balance amount stakeLists function stakeLists(address staker, uint256 index) external view returns (struct IUnderlyingStakeable.StakeStore stake) retrieve a stake at a staker's index given a staker address and an index Parameters Name Type Description staker address the staker in question index uint256 the index to focus on Return Values Name Type Description stake struct IUnderlyingStakeable.StakeStore the stake custodied by a given staker at a given index currentDay function currentDay() external view returns (uint256 day) retrieve the current day from the target contract Return Values Name Type Description day uint256 the current day according to the hex contract _currentDay function _currentDay() internal view returns (uint256) retrieve the current day from the target contract Return Values Name Type Description [0] uint256 day the current day according to the hex contract isEarlyEnding function isEarlyEnding(uint256 lockedDay, uint256 stakedDays, uint256 targetDay) external pure returns (bool isEarly) check whether or not the stake is being ended early Parameters Name Type Description lockedDay uint256 the day after the stake was locked stakedDays uint256 the number of days that the stake is locked targetDay uint256 the day to check whether it will be categorized as ending early Return Values Name Type Description isEarly bool the locked and staked days are greater than the target day (usually today) _isEarlyEnding function _isEarlyEnding(uint256 lockedDay, uint256 stakedDays, uint256 targetDay) internal pure returns (bool isEarly) check whether or not the stake is being ended early Parameters Name Type Description lockedDay uint256 the day after the stake was locked stakedDays uint256 the number of days that the stake is locked targetDay uint256 the day to check whether it will be categorized as ending early Return Values Name Type Description isEarly bool the locked and staked days are greater than the target day (usually today) stakeStart function stakeStart(uint256 newStakedHearts, uint256 newStakedDays) external virtual starts a stake from the provided amount this method interface matches the original underlying token contract Parameters Name Type Description newStakedHearts uint256 amount of tokens to stake newStakedDays uint256 the number of days for this new stake stakeEnd function stakeEnd(uint256 stakeIndex, uint40 stakeId) external virtual end your own stake which is custodied by the stake manager. skips tip computing this is not payable to match the underlying contract this moves funds back to the sender to make behavior match underlying token this method only checks that the sender owns the stake it does not care if it is managed in a created contract and externally endable by this contract (1) or requires that the staker send start and end methods (0) Parameters Name Type Description stakeIndex uint256 the index on the underlying contract to end stake stakeId uint40 the stake id from the underlying contract to end stake stakeGoodAccounting function stakeGoodAccounting(address stakerAddr, uint256 stakeIndex, uint40 stakeIdParam) external virtual freeze the progression of a stake to avoid penalties and preserve payout Parameters Name Type Description stakerAddr address the custoidan of the stake stakeIndex uint256 the index of the stake in question stakeIdParam uint40 the id of the stake","title":"UnderlyingStakeable"},{"location":"api/UnderlyingStakeable/#underlyingstakeable","text":"","title":"UnderlyingStakeable"},{"location":"api/UnderlyingStakeable/#_getstake","text":"function _getStake(address custodian, uint256 index) internal view virtual returns (struct IUnderlyingStakeable.StakeStore) gets the stake store at the provided index","title":"_getStake"},{"location":"api/UnderlyingStakeable/#parameters","text":"Name Type Description custodian address the custodian (usually this) whose list to check index uint256 the index of the stake to get","title":"Parameters"},{"location":"api/UnderlyingStakeable/#return-values","text":"Name Type Description [0] struct IUnderlyingStakeable.StakeStore the stake on the list at the provided index","title":"Return Values"},{"location":"api/UnderlyingStakeable/#stakecount","text":"function stakeCount(address staker) external view returns (uint256 count) the count of stakes for a given custodian / staker","title":"stakeCount"},{"location":"api/UnderlyingStakeable/#parameters_1","text":"Name Type Description staker address the custodian in question","title":"Parameters"},{"location":"api/UnderlyingStakeable/#return-values_1","text":"Name Type Description count uint256 of the stakes under a given custodian / staker","title":"Return Values"},{"location":"api/UnderlyingStakeable/#_stakecount","text":"function _stakeCount(address staker) internal view returns (uint256 count) the count of stakes for a given custodian / staker","title":"_stakeCount"},{"location":"api/UnderlyingStakeable/#parameters_2","text":"Name Type Description staker address the custodian in question","title":"Parameters"},{"location":"api/UnderlyingStakeable/#return-values_2","text":"Name Type Description count uint256 of the stakes under a given custodian / staker","title":"Return Values"},{"location":"api/UnderlyingStakeable/#_getstakecount","text":"function _getStakeCount(address staker) internal view virtual returns (uint256 count)","title":"_getStakeCount"},{"location":"api/UnderlyingStakeable/#balanceof","text":"function balanceOf(address owner) external view returns (uint256 amount) retrieve the balance of a given owner","title":"balanceOf"},{"location":"api/UnderlyingStakeable/#parameters_3","text":"Name Type Description owner address the owner of the tokens","title":"Parameters"},{"location":"api/UnderlyingStakeable/#return-values_3","text":"Name Type Description amount uint256 a balance amount","title":"Return Values"},{"location":"api/UnderlyingStakeable/#_balanceof","text":"function _balanceOf(address owner) internal view returns (uint256 amount) retrieve the balance of a given owner","title":"_balanceOf"},{"location":"api/UnderlyingStakeable/#parameters_4","text":"Name Type Description owner address the owner of the tokens","title":"Parameters"},{"location":"api/UnderlyingStakeable/#return-values_4","text":"Name Type Description amount uint256 a balance amount","title":"Return Values"},{"location":"api/UnderlyingStakeable/#stakelists","text":"function stakeLists(address staker, uint256 index) external view returns (struct IUnderlyingStakeable.StakeStore stake) retrieve a stake at a staker's index given a staker address and an index","title":"stakeLists"},{"location":"api/UnderlyingStakeable/#parameters_5","text":"Name Type Description staker address the staker in question index uint256 the index to focus on","title":"Parameters"},{"location":"api/UnderlyingStakeable/#return-values_5","text":"Name Type Description stake struct IUnderlyingStakeable.StakeStore the stake custodied by a given staker at a given index","title":"Return Values"},{"location":"api/UnderlyingStakeable/#currentday","text":"function currentDay() external view returns (uint256 day) retrieve the current day from the target contract","title":"currentDay"},{"location":"api/UnderlyingStakeable/#return-values_6","text":"Name Type Description day uint256 the current day according to the hex contract","title":"Return Values"},{"location":"api/UnderlyingStakeable/#_currentday","text":"function _currentDay() internal view returns (uint256) retrieve the current day from the target contract","title":"_currentDay"},{"location":"api/UnderlyingStakeable/#return-values_7","text":"Name Type Description [0] uint256 day the current day according to the hex contract","title":"Return Values"},{"location":"api/UnderlyingStakeable/#isearlyending","text":"function isEarlyEnding(uint256 lockedDay, uint256 stakedDays, uint256 targetDay) external pure returns (bool isEarly) check whether or not the stake is being ended early","title":"isEarlyEnding"},{"location":"api/UnderlyingStakeable/#parameters_6","text":"Name Type Description lockedDay uint256 the day after the stake was locked stakedDays uint256 the number of days that the stake is locked targetDay uint256 the day to check whether it will be categorized as ending early","title":"Parameters"},{"location":"api/UnderlyingStakeable/#return-values_8","text":"Name Type Description isEarly bool the locked and staked days are greater than the target day (usually today)","title":"Return Values"},{"location":"api/UnderlyingStakeable/#_isearlyending","text":"function _isEarlyEnding(uint256 lockedDay, uint256 stakedDays, uint256 targetDay) internal pure returns (bool isEarly) check whether or not the stake is being ended early","title":"_isEarlyEnding"},{"location":"api/UnderlyingStakeable/#parameters_7","text":"Name Type Description lockedDay uint256 the day after the stake was locked stakedDays uint256 the number of days that the stake is locked targetDay uint256 the day to check whether it will be categorized as ending early","title":"Parameters"},{"location":"api/UnderlyingStakeable/#return-values_9","text":"Name Type Description isEarly bool the locked and staked days are greater than the target day (usually today)","title":"Return Values"},{"location":"api/UnderlyingStakeable/#stakestart","text":"function stakeStart(uint256 newStakedHearts, uint256 newStakedDays) external virtual starts a stake from the provided amount this method interface matches the original underlying token contract","title":"stakeStart"},{"location":"api/UnderlyingStakeable/#parameters_8","text":"Name Type Description newStakedHearts uint256 amount of tokens to stake newStakedDays uint256 the number of days for this new stake","title":"Parameters"},{"location":"api/UnderlyingStakeable/#stakeend","text":"function stakeEnd(uint256 stakeIndex, uint40 stakeId) external virtual end your own stake which is custodied by the stake manager. skips tip computing this is not payable to match the underlying contract this moves funds back to the sender to make behavior match underlying token this method only checks that the sender owns the stake it does not care if it is managed in a created contract and externally endable by this contract (1) or requires that the staker send start and end methods (0)","title":"stakeEnd"},{"location":"api/UnderlyingStakeable/#parameters_9","text":"Name Type Description stakeIndex uint256 the index on the underlying contract to end stake stakeId uint40 the stake id from the underlying contract to end stake","title":"Parameters"},{"location":"api/UnderlyingStakeable/#stakegoodaccounting","text":"function stakeGoodAccounting(address stakerAddr, uint256 stakeIndex, uint40 stakeIdParam) external virtual freeze the progression of a stake to avoid penalties and preserve payout","title":"stakeGoodAccounting"},{"location":"api/UnderlyingStakeable/#parameters_10","text":"Name Type Description stakerAddr address the custoidan of the stake stakeIndex uint256 the index of the stake in question stakeIdParam uint40 the id of the stake","title":"Parameters"},{"location":"api/Utils/","text":"Utils NotAllowed error NotAllowed() the not allowed method is a general error that signifies non descript permissions issues. All transactions should always be simulated either by using gas estimations or through a static call TARGET address TARGET the hex contract to target - because this is the same on ethereum and pulsechain, we can leave it as a constant MAX_DAYS uint16 MAX_DAYS a constant for the max number of days that can be used when determining the number algorhythmically SLOTS uint16 SLOTS the number of binary slots in a 256 sized uint TEN_K uint16 TEN_K a number to use as the denominator when determining basis points ADDRESS_BIT_LENGTH uint8 ADDRESS_BIT_LENGTH the number of bits in an address MIN_INT_16 int16 MIN_INT_16 the minimum value that can exist in a int16 (-2^15) MAX_UINT_8 uint8 MAX_UINT_8 the max value that can fit in a uint8 slot (255) MAX_UINT_7 uint8 MAX_UINT_7 the max value that can fit in a uint8 slot (127) ZERO uint8 ZERO a uint8 as 0 in a constant MAX_UINT_256 uint256 MAX_UINT_256 the max uint256 that can be used ONE uint8 ONE a uint8 as 1 in a constant TWO uint8 TWO a uint8 as 2 in a constant THREE uint8 THREE a uint8 as 3 in a constant FOUR uint8 FOUR a uint8 as 4 in a constant EIGHT uint8 EIGHT a uint8 as 8 in a constant SIXTEEN uint8 SIXTEEN a uint8 as 16 in a constant TWENTY_FOUR uint8 TWENTY_FOUR a uint8 as 24 in a constant THIRTY_TWO uint8 THIRTY_TWO a uint8 as 32 in a constant FOURTY_EIGHT uint8 FOURTY_EIGHT a uint8 as 48 in a constant FIFTY_SIX uint8 FIFTY_SIX a uint8 as 56 in a constant SIXTY_FOUR uint8 SIXTY_FOUR a uint8 as 64 in a constant HEDRON address HEDRON the hedron contract to interact with and mint hedron tokens from HSIM address HSIM the hedron stake instance manager contract to interact with and transfer hsi tokens from and end stakes through COMM address COMM the address to mint communis tokens _isOneAtIndex function _isOneAtIndex(uint256 settings, uint256 index) internal pure returns (bool isOne) check if the number, in binary form, has a 1 at the provided index Parameters Name Type Description settings uint256 the settings number that holds up to 256 flags as 1/0 index uint256 the index to check for a 1 _bubbleRevert function _bubbleRevert(bytes data) internal pure after an error is caught, it can be reverted again Parameters Name Type Description data bytes the data to repackage and revert with clamp function clamp(uint256 amount, uint256 max) external pure returns (uint256 clamped) given a provided input amount, clamp the input to a maximum, using maximum if 0 provided Parameters Name Type Description amount uint256 the requested or input amount max uint256 the maximum amount that the value can be Return Values Name Type Description clamped uint256 the clamped value that is set to the limit if 0 or a number above the limit is passed _clamp function _clamp(uint256 amount, uint256 max) internal pure returns (uint256 clamped) clamp a given amount to the maximum amount use the maximum amount if no amount is requested Parameters Name Type Description amount uint256 the amount requested by another function max uint256 the limit that the value can be Return Values Name Type Description clamped uint256 the clamped value that is set to the limit if 0 or a number above the limit is passed","title":"Utils"},{"location":"api/Utils/#utils","text":"","title":"Utils"},{"location":"api/Utils/#notallowed","text":"error NotAllowed() the not allowed method is a general error that signifies non descript permissions issues. All transactions should always be simulated either by using gas estimations or through a static call","title":"NotAllowed"},{"location":"api/Utils/#target","text":"address TARGET the hex contract to target - because this is the same on ethereum and pulsechain, we can leave it as a constant","title":"TARGET"},{"location":"api/Utils/#max_days","text":"uint16 MAX_DAYS a constant for the max number of days that can be used when determining the number algorhythmically","title":"MAX_DAYS"},{"location":"api/Utils/#slots","text":"uint16 SLOTS the number of binary slots in a 256 sized uint","title":"SLOTS"},{"location":"api/Utils/#ten_k","text":"uint16 TEN_K a number to use as the denominator when determining basis points","title":"TEN_K"},{"location":"api/Utils/#address_bit_length","text":"uint8 ADDRESS_BIT_LENGTH the number of bits in an address","title":"ADDRESS_BIT_LENGTH"},{"location":"api/Utils/#min_int_16","text":"int16 MIN_INT_16 the minimum value that can exist in a int16 (-2^15)","title":"MIN_INT_16"},{"location":"api/Utils/#max_uint_8","text":"uint8 MAX_UINT_8 the max value that can fit in a uint8 slot (255)","title":"MAX_UINT_8"},{"location":"api/Utils/#max_uint_7","text":"uint8 MAX_UINT_7 the max value that can fit in a uint8 slot (127)","title":"MAX_UINT_7"},{"location":"api/Utils/#zero","text":"uint8 ZERO a uint8 as 0 in a constant","title":"ZERO"},{"location":"api/Utils/#max_uint_256","text":"uint256 MAX_UINT_256 the max uint256 that can be used","title":"MAX_UINT_256"},{"location":"api/Utils/#one","text":"uint8 ONE a uint8 as 1 in a constant","title":"ONE"},{"location":"api/Utils/#two","text":"uint8 TWO a uint8 as 2 in a constant","title":"TWO"},{"location":"api/Utils/#three","text":"uint8 THREE a uint8 as 3 in a constant","title":"THREE"},{"location":"api/Utils/#four","text":"uint8 FOUR a uint8 as 4 in a constant","title":"FOUR"},{"location":"api/Utils/#eight","text":"uint8 EIGHT a uint8 as 8 in a constant","title":"EIGHT"},{"location":"api/Utils/#sixteen","text":"uint8 SIXTEEN a uint8 as 16 in a constant","title":"SIXTEEN"},{"location":"api/Utils/#twenty_four","text":"uint8 TWENTY_FOUR a uint8 as 24 in a constant","title":"TWENTY_FOUR"},{"location":"api/Utils/#thirty_two","text":"uint8 THIRTY_TWO a uint8 as 32 in a constant","title":"THIRTY_TWO"},{"location":"api/Utils/#fourty_eight","text":"uint8 FOURTY_EIGHT a uint8 as 48 in a constant","title":"FOURTY_EIGHT"},{"location":"api/Utils/#fifty_six","text":"uint8 FIFTY_SIX a uint8 as 56 in a constant","title":"FIFTY_SIX"},{"location":"api/Utils/#sixty_four","text":"uint8 SIXTY_FOUR a uint8 as 64 in a constant","title":"SIXTY_FOUR"},{"location":"api/Utils/#hedron","text":"address HEDRON the hedron contract to interact with and mint hedron tokens from","title":"HEDRON"},{"location":"api/Utils/#hsim","text":"address HSIM the hedron stake instance manager contract to interact with and transfer hsi tokens from and end stakes through","title":"HSIM"},{"location":"api/Utils/#comm","text":"address COMM the address to mint communis tokens","title":"COMM"},{"location":"api/Utils/#_isoneatindex","text":"function _isOneAtIndex(uint256 settings, uint256 index) internal pure returns (bool isOne) check if the number, in binary form, has a 1 at the provided index","title":"_isOneAtIndex"},{"location":"api/Utils/#parameters","text":"Name Type Description settings uint256 the settings number that holds up to 256 flags as 1/0 index uint256 the index to check for a 1","title":"Parameters"},{"location":"api/Utils/#_bubblerevert","text":"function _bubbleRevert(bytes data) internal pure after an error is caught, it can be reverted again","title":"_bubbleRevert"},{"location":"api/Utils/#parameters_1","text":"Name Type Description data bytes the data to repackage and revert with","title":"Parameters"},{"location":"api/Utils/#clamp","text":"function clamp(uint256 amount, uint256 max) external pure returns (uint256 clamped) given a provided input amount, clamp the input to a maximum, using maximum if 0 provided","title":"clamp"},{"location":"api/Utils/#parameters_2","text":"Name Type Description amount uint256 the requested or input amount max uint256 the maximum amount that the value can be","title":"Parameters"},{"location":"api/Utils/#return-values","text":"Name Type Description clamped uint256 the clamped value that is set to the limit if 0 or a number above the limit is passed","title":"Return Values"},{"location":"api/Utils/#_clamp","text":"function _clamp(uint256 amount, uint256 max) internal pure returns (uint256 clamped) clamp a given amount to the maximum amount use the maximum amount if no amount is requested","title":"_clamp"},{"location":"api/Utils/#parameters_3","text":"Name Type Description amount uint256 the amount requested by another function max uint256 the limit that the value can be","title":"Parameters"},{"location":"api/Utils/#return-values_1","text":"Name Type Description clamped uint256 the clamped value that is set to the limit if 0 or a number above the limit is passed","title":"Return Values"},{"location":"api/interfaces/Communis/","text":"Communis Stake struct Stake { uint256 stakeId; uint256 stakedHearts; uint256 stakeShares; uint256 lockedDay; uint256 stakedDays; uint256 unlockedDay; } PayoutResponse struct PayoutResponse { uint256 recalculatedStakeShares; uint256 stakesOriginalShareRate; uint256 maxPayout; } mintEndBonus function mintEndBonus(uint256 stakeIndex, uint256 stakeId, address referrer, uint256 stakeAmount) external virtual mintGoodAccountingBonus function mintGoodAccountingBonus(address stakeOwner, uint256 stakeIndex, uint256 stakeId) external virtual mintStakeBonus function mintStakeBonus() external virtual mintStartBonus function mintStartBonus(uint256 stakeIndex, uint256 stakeId, bool applyRestakeBonus, address referrer, uint256 stakeAmount) external virtual stakeIdGoodAccountingBonusPayout function stakeIdGoodAccountingBonusPayout(uint256 stakeId) external view virtual returns (uint256) stakeIdEndBonusPayout function stakeIdEndBonusPayout(uint256 stakeId) external view virtual returns (uint256) stakeIdStartBonusPayout function stakeIdStartBonusPayout(uint256 stakeId) external view virtual returns (uint256) addressStakedCodeak function addressStakedCodeak(address owner) external view virtual returns (uint256) withdrawStakedCodeak function withdrawStakedCodeak(uint256 withdrawAmount) external virtual getPayout function getPayout(struct Communis.Stake s) external pure virtual returns (struct Communis.PayoutResponse pr) getStartBonusPayout function getStartBonusPayout(uint256 stakedDays, uint256 lockedDay, uint256 maxPayout, uint256 stakesOriginalShareRate, uint256 currentDay, uint256 globalShareRate, bool applyRestakeBonus) external pure virtual returns (uint256 payout)","title":"Communis"},{"location":"api/interfaces/Communis/#communis","text":"","title":"Communis"},{"location":"api/interfaces/Communis/#stake","text":"struct Stake { uint256 stakeId; uint256 stakedHearts; uint256 stakeShares; uint256 lockedDay; uint256 stakedDays; uint256 unlockedDay; }","title":"Stake"},{"location":"api/interfaces/Communis/#payoutresponse","text":"struct PayoutResponse { uint256 recalculatedStakeShares; uint256 stakesOriginalShareRate; uint256 maxPayout; }","title":"PayoutResponse"},{"location":"api/interfaces/Communis/#mintendbonus","text":"function mintEndBonus(uint256 stakeIndex, uint256 stakeId, address referrer, uint256 stakeAmount) external virtual","title":"mintEndBonus"},{"location":"api/interfaces/Communis/#mintgoodaccountingbonus","text":"function mintGoodAccountingBonus(address stakeOwner, uint256 stakeIndex, uint256 stakeId) external virtual","title":"mintGoodAccountingBonus"},{"location":"api/interfaces/Communis/#mintstakebonus","text":"function mintStakeBonus() external virtual","title":"mintStakeBonus"},{"location":"api/interfaces/Communis/#mintstartbonus","text":"function mintStartBonus(uint256 stakeIndex, uint256 stakeId, bool applyRestakeBonus, address referrer, uint256 stakeAmount) external virtual","title":"mintStartBonus"},{"location":"api/interfaces/Communis/#stakeidgoodaccountingbonuspayout","text":"function stakeIdGoodAccountingBonusPayout(uint256 stakeId) external view virtual returns (uint256)","title":"stakeIdGoodAccountingBonusPayout"},{"location":"api/interfaces/Communis/#stakeidendbonuspayout","text":"function stakeIdEndBonusPayout(uint256 stakeId) external view virtual returns (uint256)","title":"stakeIdEndBonusPayout"},{"location":"api/interfaces/Communis/#stakeidstartbonuspayout","text":"function stakeIdStartBonusPayout(uint256 stakeId) external view virtual returns (uint256)","title":"stakeIdStartBonusPayout"},{"location":"api/interfaces/Communis/#addressstakedcodeak","text":"function addressStakedCodeak(address owner) external view virtual returns (uint256)","title":"addressStakedCodeak"},{"location":"api/interfaces/Communis/#withdrawstakedcodeak","text":"function withdrawStakedCodeak(uint256 withdrawAmount) external virtual","title":"withdrawStakedCodeak"},{"location":"api/interfaces/Communis/#getpayout","text":"function getPayout(struct Communis.Stake s) external pure virtual returns (struct Communis.PayoutResponse pr)","title":"getPayout"},{"location":"api/interfaces/Communis/#getstartbonuspayout","text":"function getStartBonusPayout(uint256 stakedDays, uint256 lockedDay, uint256 maxPayout, uint256 stakesOriginalShareRate, uint256 currentDay, uint256 globalShareRate, bool applyRestakeBonus) external pure virtual returns (uint256 payout)","title":"getStartBonusPayout"},{"location":"api/interfaces/ExternalPerpetualFilter/","text":"ExternalPerpetualFilter verifyPerpetual function verifyPerpetual(address perpetual) external view virtual returns (bool isPerpetual)","title":"ExternalPerpetualFilter"},{"location":"api/interfaces/ExternalPerpetualFilter/#externalperpetualfilter","text":"","title":"ExternalPerpetualFilter"},{"location":"api/interfaces/ExternalPerpetualFilter/#verifyperpetual","text":"function verifyPerpetual(address perpetual) external view virtual returns (bool isPerpetual)","title":"verifyPerpetual"},{"location":"api/interfaces/GasReimberser/","text":"GasReimberser flush function flush() external virtual flush_erc20 function flush_erc20(address token) external virtual","title":"GasReimberser"},{"location":"api/interfaces/GasReimberser/#gasreimberser","text":"","title":"GasReimberser"},{"location":"api/interfaces/GasReimberser/#flush","text":"function flush() external virtual","title":"flush"},{"location":"api/interfaces/GasReimberser/#flush_erc20","text":"function flush_erc20(address token) external virtual","title":"flush_erc20"},{"location":"api/interfaces/HEX/","text":"HEX XfLobbyEnter event XfLobbyEnter(uint256 data0, address memberAddr, uint256 entryId, address referrerAddr) XfLobbyExit event XfLobbyExit(uint256 data0, address memberAddr, uint256 entryId, address referrerAddr) DailyDataUpdate event DailyDataUpdate(uint256 data0, address updaterAddr) Claim event Claim(uint256 data0, uint256 data1, bytes20 btcAddr, address claimToAddr, address referrerAddr) ClaimAssist event ClaimAssist(uint256 data0, uint256 data1, uint256 data2, address senderAddr) StakeStart event StakeStart(uint256 data0, address stakerAddr, uint40 stakeId) StakeGoodAccounting event StakeGoodAccounting(uint256 data0, uint256 data1, address stakerAddr, uint40 stakeId, address senderAddr) StakeEnd event StakeEnd(uint256 data0, uint256 data1, address stakerAddr, uint40 stakeId) ShareRateChange event ShareRateChange(uint256 data0, uint40 stakeId) stakeLists function stakeLists(address staker, uint256 index) external view virtual returns (struct IUnderlyingStakeable.StakeStore) retrieve a stake at a staker's index given a staker address and an index Parameters Name Type Description staker address the staker in question index uint256 the index to focus on Return Values Name Type Description [0] struct IUnderlyingStakeable.StakeStore stake the stake custodied by a given staker at a given index currentDay function currentDay() external view virtual returns (uint256) retrieve the current day from the target contract Return Values Name Type Description [0] uint256 day the current day according to the hex contract globalInfo function globalInfo() external view virtual returns (uint256[13]) dailyData function dailyData(uint256 day) external view virtual returns (uint72 dayPayoutTotal, uint72 dayStakeSharesTotal, uint56 dayUnclaimedSatoshisTotal) dailyDataRange function dailyDataRange(uint256 beginDay, uint256 endDay) external view virtual returns (uint256[] list)","title":"HEX"},{"location":"api/interfaces/HEX/#hex","text":"","title":"HEX"},{"location":"api/interfaces/HEX/#xflobbyenter","text":"event XfLobbyEnter(uint256 data0, address memberAddr, uint256 entryId, address referrerAddr)","title":"XfLobbyEnter"},{"location":"api/interfaces/HEX/#xflobbyexit","text":"event XfLobbyExit(uint256 data0, address memberAddr, uint256 entryId, address referrerAddr)","title":"XfLobbyExit"},{"location":"api/interfaces/HEX/#dailydataupdate","text":"event DailyDataUpdate(uint256 data0, address updaterAddr)","title":"DailyDataUpdate"},{"location":"api/interfaces/HEX/#claim","text":"event Claim(uint256 data0, uint256 data1, bytes20 btcAddr, address claimToAddr, address referrerAddr)","title":"Claim"},{"location":"api/interfaces/HEX/#claimassist","text":"event ClaimAssist(uint256 data0, uint256 data1, uint256 data2, address senderAddr)","title":"ClaimAssist"},{"location":"api/interfaces/HEX/#stakestart","text":"event StakeStart(uint256 data0, address stakerAddr, uint40 stakeId)","title":"StakeStart"},{"location":"api/interfaces/HEX/#stakegoodaccounting","text":"event StakeGoodAccounting(uint256 data0, uint256 data1, address stakerAddr, uint40 stakeId, address senderAddr)","title":"StakeGoodAccounting"},{"location":"api/interfaces/HEX/#stakeend","text":"event StakeEnd(uint256 data0, uint256 data1, address stakerAddr, uint40 stakeId)","title":"StakeEnd"},{"location":"api/interfaces/HEX/#shareratechange","text":"event ShareRateChange(uint256 data0, uint40 stakeId)","title":"ShareRateChange"},{"location":"api/interfaces/HEX/#stakelists","text":"function stakeLists(address staker, uint256 index) external view virtual returns (struct IUnderlyingStakeable.StakeStore) retrieve a stake at a staker's index given a staker address and an index","title":"stakeLists"},{"location":"api/interfaces/HEX/#parameters","text":"Name Type Description staker address the staker in question index uint256 the index to focus on","title":"Parameters"},{"location":"api/interfaces/HEX/#return-values","text":"Name Type Description [0] struct IUnderlyingStakeable.StakeStore stake the stake custodied by a given staker at a given index","title":"Return Values"},{"location":"api/interfaces/HEX/#currentday","text":"function currentDay() external view virtual returns (uint256) retrieve the current day from the target contract","title":"currentDay"},{"location":"api/interfaces/HEX/#return-values_1","text":"Name Type Description [0] uint256 day the current day according to the hex contract","title":"Return Values"},{"location":"api/interfaces/HEX/#globalinfo","text":"function globalInfo() external view virtual returns (uint256[13])","title":"globalInfo"},{"location":"api/interfaces/HEX/#dailydata","text":"function dailyData(uint256 day) external view virtual returns (uint72 dayPayoutTotal, uint72 dayStakeSharesTotal, uint56 dayUnclaimedSatoshisTotal)","title":"dailyData"},{"location":"api/interfaces/HEX/#dailydatarange","text":"function dailyDataRange(uint256 beginDay, uint256 endDay) external view virtual returns (uint256[] list)","title":"dailyDataRange"},{"location":"api/interfaces/HEXStakeInstanceManager/","text":"HEXStakeInstanceManager HSIStart event HSIStart(uint256 timestamp, address hsiAddress, address staker) HSIEnd event HSIEnd(uint256 timestamp, address hsiAddress, address staker) HSITransfer event HSITransfer(uint256 timestamp, address hsiAddress, address oldStaker, address newStaker) HSITokenize event HSITokenize(uint256 timestamp, uint256 hsiTokenId, address hsiAddress, address staker) HSIDetokenize event HSIDetokenize(uint256 timestamp, uint256 hsiTokenId, address hsiAddress, address staker) hsiLists function hsiLists(address generator, uint256 index) external view virtual returns (address) hsiCount function hsiCount(address originator) external view virtual returns (uint256) hexStakeDetokenize function hexStakeDetokenize(uint256 tokenId) external virtual returns (address) hexStakeTokenize function hexStakeTokenize(uint256 hsiIndex, address hsiAddress) external virtual returns (uint256) hexStakeEnd function hexStakeEnd(uint256 hsiIndex, address hsiAddress) external virtual returns (uint256) hexStakeStart function hexStakeStart(uint256 amount, uint256 length) external virtual returns (address) hsiToken function hsiToken(uint256 tokenId) external view virtual returns (address) tokenOfOwnerByIndex function tokenOfOwnerByIndex(address account, uint256 index) external view virtual returns (uint256)","title":"HEXStakeInstanceManager"},{"location":"api/interfaces/HEXStakeInstanceManager/#hexstakeinstancemanager","text":"","title":"HEXStakeInstanceManager"},{"location":"api/interfaces/HEXStakeInstanceManager/#hsistart","text":"event HSIStart(uint256 timestamp, address hsiAddress, address staker)","title":"HSIStart"},{"location":"api/interfaces/HEXStakeInstanceManager/#hsiend","text":"event HSIEnd(uint256 timestamp, address hsiAddress, address staker)","title":"HSIEnd"},{"location":"api/interfaces/HEXStakeInstanceManager/#hsitransfer","text":"event HSITransfer(uint256 timestamp, address hsiAddress, address oldStaker, address newStaker)","title":"HSITransfer"},{"location":"api/interfaces/HEXStakeInstanceManager/#hsitokenize","text":"event HSITokenize(uint256 timestamp, uint256 hsiTokenId, address hsiAddress, address staker)","title":"HSITokenize"},{"location":"api/interfaces/HEXStakeInstanceManager/#hsidetokenize","text":"event HSIDetokenize(uint256 timestamp, uint256 hsiTokenId, address hsiAddress, address staker)","title":"HSIDetokenize"},{"location":"api/interfaces/HEXStakeInstanceManager/#hsilists","text":"function hsiLists(address generator, uint256 index) external view virtual returns (address)","title":"hsiLists"},{"location":"api/interfaces/HEXStakeInstanceManager/#hsicount","text":"function hsiCount(address originator) external view virtual returns (uint256)","title":"hsiCount"},{"location":"api/interfaces/HEXStakeInstanceManager/#hexstakedetokenize","text":"function hexStakeDetokenize(uint256 tokenId) external virtual returns (address)","title":"hexStakeDetokenize"},{"location":"api/interfaces/HEXStakeInstanceManager/#hexstaketokenize","text":"function hexStakeTokenize(uint256 hsiIndex, address hsiAddress) external virtual returns (uint256)","title":"hexStakeTokenize"},{"location":"api/interfaces/HEXStakeInstanceManager/#hexstakeend","text":"function hexStakeEnd(uint256 hsiIndex, address hsiAddress) external virtual returns (uint256)","title":"hexStakeEnd"},{"location":"api/interfaces/HEXStakeInstanceManager/#hexstakestart","text":"function hexStakeStart(uint256 amount, uint256 length) external virtual returns (address)","title":"hexStakeStart"},{"location":"api/interfaces/HEXStakeInstanceManager/#hsitoken","text":"function hsiToken(uint256 tokenId) external view virtual returns (address)","title":"hsiToken"},{"location":"api/interfaces/HEXStakeInstanceManager/#tokenofownerbyindex","text":"function tokenOfOwnerByIndex(address account, uint256 index) external view virtual returns (uint256)","title":"tokenOfOwnerByIndex"},{"location":"api/interfaces/Hedron/","text":"Hedron Claim event Claim(uint256 data, address claimant, uint40 stakeId) LoanEnd event LoanEnd(uint256 data, address borrower, uint40 stakeId) LoanLiquidateBid event LoanLiquidateBid(uint256 data, address bidder, uint40 stakeId, uint40 liquidationId) LoanLiquidateExit event LoanLiquidateExit(uint256 data, address liquidator, uint40 stakeId, uint40 liquidationId) LoanLiquidateStart event LoanLiquidateStart(uint256 data, address borrower, uint40 stakeId, uint40 liquidationId) LoanPayment event LoanPayment(uint256 data, address borrower, uint40 stakeId) LoanStart event LoanStart(uint256 data, address borrower, uint40 stakeId) Mint event Mint(uint256 data, address minter, uint40 stakeId) hsim function hsim() external view virtual returns (address) mintInstanced function mintInstanced(uint256 hsiIndex, address hsiAddress) external virtual returns (uint256) mintNative function mintNative(uint256 stakeIndex, uint40 stakeId) external virtual returns (uint256)","title":"Hedron"},{"location":"api/interfaces/Hedron/#hedron","text":"","title":"Hedron"},{"location":"api/interfaces/Hedron/#claim","text":"event Claim(uint256 data, address claimant, uint40 stakeId)","title":"Claim"},{"location":"api/interfaces/Hedron/#loanend","text":"event LoanEnd(uint256 data, address borrower, uint40 stakeId)","title":"LoanEnd"},{"location":"api/interfaces/Hedron/#loanliquidatebid","text":"event LoanLiquidateBid(uint256 data, address bidder, uint40 stakeId, uint40 liquidationId)","title":"LoanLiquidateBid"},{"location":"api/interfaces/Hedron/#loanliquidateexit","text":"event LoanLiquidateExit(uint256 data, address liquidator, uint40 stakeId, uint40 liquidationId)","title":"LoanLiquidateExit"},{"location":"api/interfaces/Hedron/#loanliquidatestart","text":"event LoanLiquidateStart(uint256 data, address borrower, uint40 stakeId, uint40 liquidationId)","title":"LoanLiquidateStart"},{"location":"api/interfaces/Hedron/#loanpayment","text":"event LoanPayment(uint256 data, address borrower, uint40 stakeId)","title":"LoanPayment"},{"location":"api/interfaces/Hedron/#loanstart","text":"event LoanStart(uint256 data, address borrower, uint40 stakeId)","title":"LoanStart"},{"location":"api/interfaces/Hedron/#mint","text":"event Mint(uint256 data, address minter, uint40 stakeId)","title":"Mint"},{"location":"api/interfaces/Hedron/#hsim","text":"function hsim() external view virtual returns (address)","title":"hsim"},{"location":"api/interfaces/Hedron/#mintinstanced","text":"function mintInstanced(uint256 hsiIndex, address hsiAddress) external virtual returns (uint256)","title":"mintInstanced"},{"location":"api/interfaces/Hedron/#mintnative","text":"function mintNative(uint256 stakeIndex, uint40 stakeId) external virtual returns (uint256)","title":"mintNative"},{"location":"api/interfaces/IUnderlyingStakeable/","text":"IUnderlyingStakeable this is the minimum interface needed to start and end stakes appropriately on hex StakeStore struct StakeStore { uint40 stakeId; uint72 stakedHearts; uint72 stakeShares; uint16 lockedDay; uint16 stakedDays; uint16 unlockedDay; bool isAutoStake; } stakeStart function stakeStart(uint256 newStakedHearts, uint256 newStakedDays) external starts a stake from the provided amount this method interface matches the original underlying token contract Parameters Name Type Description newStakedHearts uint256 amount of tokens to stake newStakedDays uint256 the number of days for this new stake stakeEnd function stakeEnd(uint256 stakeIndex, uint40 stakeId) external end your own stake which is custodied by the stake manager. skips tip computing this is not payable to match the underlying contract this moves funds back to the sender to make behavior match underlying token this method only checks that the sender owns the stake it does not care if it is managed in a created contract and externally endable by this contract (1) or requires that the staker send start and end methods (0) Parameters Name Type Description stakeIndex uint256 the index on the underlying contract to end stake stakeId uint40 the stake id from the underlying contract to end stake stakeGoodAccounting function stakeGoodAccounting(address stakerAddr, uint256 stakeIndex, uint40 stakeIdParam) external freeze the progression of a stake to avoid penalties and preserve payout Parameters Name Type Description stakerAddr address the custoidan of the stake stakeIndex uint256 the index of the stake in question stakeIdParam uint40 the id of the stake stakeCount function stakeCount(address staker) external view returns (uint256 count) the count of stakes for a given custodian / staker Parameters Name Type Description staker address the custodian in question Return Values Name Type Description count uint256 of the stakes under a given custodian / staker stakeLists function stakeLists(address staker, uint256 index) external view returns (struct IUnderlyingStakeable.StakeStore) retrieve a stake at a staker's index given a staker address and an index Parameters Name Type Description staker address the staker in question index uint256 the index to focus on Return Values Name Type Description [0] struct IUnderlyingStakeable.StakeStore stake the stake custodied by a given staker at a given index currentDay function currentDay() external view returns (uint256) retrieve the current day from the target contract Return Values Name Type Description [0] uint256 day the current day according to the hex contract","title":"IUnderlyingStakeable"},{"location":"api/interfaces/IUnderlyingStakeable/#iunderlyingstakeable","text":"this is the minimum interface needed to start and end stakes appropriately on hex","title":"IUnderlyingStakeable"},{"location":"api/interfaces/IUnderlyingStakeable/#stakestore","text":"struct StakeStore { uint40 stakeId; uint72 stakedHearts; uint72 stakeShares; uint16 lockedDay; uint16 stakedDays; uint16 unlockedDay; bool isAutoStake; }","title":"StakeStore"},{"location":"api/interfaces/IUnderlyingStakeable/#stakestart","text":"function stakeStart(uint256 newStakedHearts, uint256 newStakedDays) external starts a stake from the provided amount this method interface matches the original underlying token contract","title":"stakeStart"},{"location":"api/interfaces/IUnderlyingStakeable/#parameters","text":"Name Type Description newStakedHearts uint256 amount of tokens to stake newStakedDays uint256 the number of days for this new stake","title":"Parameters"},{"location":"api/interfaces/IUnderlyingStakeable/#stakeend","text":"function stakeEnd(uint256 stakeIndex, uint40 stakeId) external end your own stake which is custodied by the stake manager. skips tip computing this is not payable to match the underlying contract this moves funds back to the sender to make behavior match underlying token this method only checks that the sender owns the stake it does not care if it is managed in a created contract and externally endable by this contract (1) or requires that the staker send start and end methods (0)","title":"stakeEnd"},{"location":"api/interfaces/IUnderlyingStakeable/#parameters_1","text":"Name Type Description stakeIndex uint256 the index on the underlying contract to end stake stakeId uint40 the stake id from the underlying contract to end stake","title":"Parameters"},{"location":"api/interfaces/IUnderlyingStakeable/#stakegoodaccounting","text":"function stakeGoodAccounting(address stakerAddr, uint256 stakeIndex, uint40 stakeIdParam) external freeze the progression of a stake to avoid penalties and preserve payout","title":"stakeGoodAccounting"},{"location":"api/interfaces/IUnderlyingStakeable/#parameters_2","text":"Name Type Description stakerAddr address the custoidan of the stake stakeIndex uint256 the index of the stake in question stakeIdParam uint40 the id of the stake","title":"Parameters"},{"location":"api/interfaces/IUnderlyingStakeable/#stakecount","text":"function stakeCount(address staker) external view returns (uint256 count) the count of stakes for a given custodian / staker","title":"stakeCount"},{"location":"api/interfaces/IUnderlyingStakeable/#parameters_3","text":"Name Type Description staker address the custodian in question","title":"Parameters"},{"location":"api/interfaces/IUnderlyingStakeable/#return-values","text":"Name Type Description count uint256 of the stakes under a given custodian / staker","title":"Return Values"},{"location":"api/interfaces/IUnderlyingStakeable/#stakelists","text":"function stakeLists(address staker, uint256 index) external view returns (struct IUnderlyingStakeable.StakeStore) retrieve a stake at a staker's index given a staker address and an index","title":"stakeLists"},{"location":"api/interfaces/IUnderlyingStakeable/#parameters_4","text":"Name Type Description staker address the staker in question index uint256 the index to focus on","title":"Parameters"},{"location":"api/interfaces/IUnderlyingStakeable/#return-values_1","text":"Name Type Description [0] struct IUnderlyingStakeable.StakeStore stake the stake custodied by a given staker at a given index","title":"Return Values"},{"location":"api/interfaces/IUnderlyingStakeable/#currentday","text":"function currentDay() external view returns (uint256) retrieve the current day from the target contract","title":"currentDay"},{"location":"api/interfaces/IUnderlyingStakeable/#return-values_2","text":"Name Type Description [0] uint256 day the current day according to the hex contract","title":"Return Values"},{"location":"api/interfaces/MaximusPerpetual/","text":"MaximusPerpetual getEndStaker function getEndStaker() external view virtual returns (address end_staker_address)","title":"MaximusPerpetual"},{"location":"api/interfaces/MaximusPerpetual/#maximusperpetual","text":"","title":"MaximusPerpetual"},{"location":"api/interfaces/MaximusPerpetual/#getendstaker","text":"function getEndStaker() external view virtual returns (address end_staker_address)","title":"getEndStaker"},{"location":"api/interfaces/Multicall/","text":"Multicall Call struct Call { address target; bytes callData; } Call3 struct Call3 { address target; bool allowFailure; bytes callData; } Call3Value struct Call3Value { address target; bool allowFailure; uint256 value; bytes callData; } Result struct Result { bool success; bytes returnData; } aggregate function aggregate(struct Multicall.Call[] calls) external payable virtual returns (uint256 blockNumber, bytes[] returnData) aggregate3 function aggregate3(struct Multicall.Call3[] calls) external payable virtual returns (struct Multicall.Result[] returnData) aggregate3Value function aggregate3Value(struct Multicall.Call3Value[] calls) external payable virtual returns (struct Multicall.Result[] returnData) blockAndAggregate function blockAndAggregate(struct Multicall.Call[] calls) external payable virtual returns (uint256 blockNumber, bytes32 blockHash, struct Multicall.Result[] returnData) getBasefee function getBasefee() external view virtual returns (uint256 basefee) getBlockHash function getBlockHash(uint256 blockNumber) external view virtual returns (bytes32 blockHash) getBlockNumber function getBlockNumber() external view virtual returns (uint256 blockNumber) getChainId function getChainId() external view virtual returns (uint256 chainid) getCurrentBlockCoinbase function getCurrentBlockCoinbase() external view virtual returns (address coinbase) getCurrentBlockDifficulty function getCurrentBlockDifficulty() external view virtual returns (uint256 difficulty) getCurrentBlockGasLimit function getCurrentBlockGasLimit() external view virtual returns (uint256 gaslimit) getCurrentBlockTimestamp function getCurrentBlockTimestamp() external view virtual returns (uint256 timestamp) getEthBalance function getEthBalance(address addr) external view virtual returns (uint256 balance) getLastBlockHash function getLastBlockHash() external view virtual returns (bytes32 blockHash) tryAggregate function tryAggregate(bool requireSuccess, struct Multicall.Call[] calls) external payable virtual returns (struct Multicall.Result[] returnData) tryBlockAndAggregate function tryBlockAndAggregate(bool requireSuccess, struct Multicall.Call[] calls) external payable virtual returns (uint256 blockNumber, bytes32 blockHash, struct Multicall.Result[] returnData)","title":"Multicall"},{"location":"api/interfaces/Multicall/#multicall","text":"","title":"Multicall"},{"location":"api/interfaces/Multicall/#call","text":"struct Call { address target; bytes callData; }","title":"Call"},{"location":"api/interfaces/Multicall/#call3","text":"struct Call3 { address target; bool allowFailure; bytes callData; }","title":"Call3"},{"location":"api/interfaces/Multicall/#call3value","text":"struct Call3Value { address target; bool allowFailure; uint256 value; bytes callData; }","title":"Call3Value"},{"location":"api/interfaces/Multicall/#result","text":"struct Result { bool success; bytes returnData; }","title":"Result"},{"location":"api/interfaces/Multicall/#aggregate","text":"function aggregate(struct Multicall.Call[] calls) external payable virtual returns (uint256 blockNumber, bytes[] returnData)","title":"aggregate"},{"location":"api/interfaces/Multicall/#aggregate3","text":"function aggregate3(struct Multicall.Call3[] calls) external payable virtual returns (struct Multicall.Result[] returnData)","title":"aggregate3"},{"location":"api/interfaces/Multicall/#aggregate3value","text":"function aggregate3Value(struct Multicall.Call3Value[] calls) external payable virtual returns (struct Multicall.Result[] returnData)","title":"aggregate3Value"},{"location":"api/interfaces/Multicall/#blockandaggregate","text":"function blockAndAggregate(struct Multicall.Call[] calls) external payable virtual returns (uint256 blockNumber, bytes32 blockHash, struct Multicall.Result[] returnData)","title":"blockAndAggregate"},{"location":"api/interfaces/Multicall/#getbasefee","text":"function getBasefee() external view virtual returns (uint256 basefee)","title":"getBasefee"},{"location":"api/interfaces/Multicall/#getblockhash","text":"function getBlockHash(uint256 blockNumber) external view virtual returns (bytes32 blockHash)","title":"getBlockHash"},{"location":"api/interfaces/Multicall/#getblocknumber","text":"function getBlockNumber() external view virtual returns (uint256 blockNumber)","title":"getBlockNumber"},{"location":"api/interfaces/Multicall/#getchainid","text":"function getChainId() external view virtual returns (uint256 chainid)","title":"getChainId"},{"location":"api/interfaces/Multicall/#getcurrentblockcoinbase","text":"function getCurrentBlockCoinbase() external view virtual returns (address coinbase)","title":"getCurrentBlockCoinbase"},{"location":"api/interfaces/Multicall/#getcurrentblockdifficulty","text":"function getCurrentBlockDifficulty() external view virtual returns (uint256 difficulty)","title":"getCurrentBlockDifficulty"},{"location":"api/interfaces/Multicall/#getcurrentblockgaslimit","text":"function getCurrentBlockGasLimit() external view virtual returns (uint256 gaslimit)","title":"getCurrentBlockGasLimit"},{"location":"api/interfaces/Multicall/#getcurrentblocktimestamp","text":"function getCurrentBlockTimestamp() external view virtual returns (uint256 timestamp)","title":"getCurrentBlockTimestamp"},{"location":"api/interfaces/Multicall/#getethbalance","text":"function getEthBalance(address addr) external view virtual returns (uint256 balance)","title":"getEthBalance"},{"location":"api/interfaces/Multicall/#getlastblockhash","text":"function getLastBlockHash() external view virtual returns (bytes32 blockHash)","title":"getLastBlockHash"},{"location":"api/interfaces/Multicall/#tryaggregate","text":"function tryAggregate(bool requireSuccess, struct Multicall.Call[] calls) external payable virtual returns (struct Multicall.Result[] returnData)","title":"tryAggregate"},{"location":"api/interfaces/Multicall/#tryblockandaggregate","text":"function tryBlockAndAggregate(bool requireSuccess, struct Multicall.Call[] calls) external payable virtual returns (uint256 blockNumber, bytes32 blockHash, struct Multicall.Result[] returnData)","title":"tryBlockAndAggregate"},{"location":"api/interfaces/PublicEndStakeable/","text":"PublicEndStakeable STAKE_END_DAY function STAKE_END_DAY() external view virtual returns (uint256) STAKE_IS_ACTIVE function STAKE_IS_ACTIVE() external view virtual returns (bool) mintEndBonusCom function mintEndBonusCom(uint256 stakeIndex, uint40 stakeIdParam) external virtual mintHedron function mintHedron(uint256 stakeIndex, uint40 stakeIdParam) external virtual endStakeHEX function endStakeHEX(uint256 stakeIndex, uint40 stakeIdParam) external virtual getCurrentPeriod function getCurrentPeriod() external view virtual returns (uint256) getEndStaker function getEndStaker() external view virtual returns (address end_staker_address)","title":"PublicEndStakeable"},{"location":"api/interfaces/PublicEndStakeable/#publicendstakeable","text":"","title":"PublicEndStakeable"},{"location":"api/interfaces/PublicEndStakeable/#stake_end_day","text":"function STAKE_END_DAY() external view virtual returns (uint256)","title":"STAKE_END_DAY"},{"location":"api/interfaces/PublicEndStakeable/#stake_is_active","text":"function STAKE_IS_ACTIVE() external view virtual returns (bool)","title":"STAKE_IS_ACTIVE"},{"location":"api/interfaces/PublicEndStakeable/#mintendbonuscom","text":"function mintEndBonusCom(uint256 stakeIndex, uint40 stakeIdParam) external virtual","title":"mintEndBonusCom"},{"location":"api/interfaces/PublicEndStakeable/#minthedron","text":"function mintHedron(uint256 stakeIndex, uint40 stakeIdParam) external virtual","title":"mintHedron"},{"location":"api/interfaces/PublicEndStakeable/#endstakehex","text":"function endStakeHEX(uint256 stakeIndex, uint40 stakeIdParam) external virtual","title":"endStakeHEX"},{"location":"api/interfaces/PublicEndStakeable/#getcurrentperiod","text":"function getCurrentPeriod() external view virtual returns (uint256)","title":"getCurrentPeriod"},{"location":"api/interfaces/PublicEndStakeable/#getendstaker","text":"function getEndStaker() external view virtual returns (address end_staker_address)","title":"getEndStaker"},{"location":"api/interfaces/StakeReceiver/","text":"StakeReceiver onStakeReceived function onStakeReceived(address from, address owner, uint256 stakeId) external virtual returns (bytes4)","title":"StakeReceiver"},{"location":"api/interfaces/StakeReceiver/#stakereceiver","text":"","title":"StakeReceiver"},{"location":"api/interfaces/StakeReceiver/#onstakereceived","text":"function onStakeReceived(address from, address owner, uint256 stakeId) external virtual returns (bytes4)","title":"onStakeReceived"}]}